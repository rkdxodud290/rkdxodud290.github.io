<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pong Pro - Enhanced UI/UX</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet"> {/* Font Awesome for icons */}
    <style>
        /* Import Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --bg-primary: #1a1d24; /* Darker, richer background */
            --bg-secondary: #252a33; /* Container background */
            --bg-canvas: #0f1218; /* Canvas background */
            --text-primary: #e0e6f0;
            --text-secondary: #a0aec0;
            --accent-primary: #4f80e1; /* Vibrant Blue */
            --accent-secondary: #31c48d; /* Green for positive actions/difficulty */
            --accent-danger: #e54848; /* Red for AI paddle/warnings */
            --border-color: var(--accent-primary);
            --shadow-color-light: rgba(79, 128, 225, 0.5);
            --shadow-color-dark: rgba(0, 0, 0, 0.3);
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-primary);
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 900px;
            display: flex;
            justify-content: center;
            margin-bottom: 1rem; /* Space for controls below */
        }

        canvas#pongCanvas {
            background-color: var(--bg-canvas);
            border: 3px solid var(--border-color);
            border-radius: 1rem;
            display: block;
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            box-shadow: inset 0 0 25px rgba(79, 128, 225, 0.3); /* More subtle inset shadow */
            z-index: 5;
            position: relative; /* For overlay positioning */
        }
        /* Overlay for Pause/Game Over messages on canvas */
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 6; /* Above canvas, below touch controls if they were separate */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            border-radius: calc(1rem - 3px); /* Match canvas border-radius minus border width */
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0,0,0,0.7);
        }
        .canvas-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .canvas-overlay .final-score {
            font-size: 1.5rem;
            font-weight: 500;
            margin-top: 0.5rem;
            color: var(--text-secondary);
        }


        .touch-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
        }
        .touch-area { flex-grow: 1; }


        .game-container {
            background-color: var(--bg-secondary);
            border-radius: 1.25rem; /* Slightly adjusted */
            box-shadow: 0 15px 30px var(--shadow-color-dark); /* Refined shadow */
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.8rem;
            max-width: 95vw;
            width: 900px;
            margin: 1rem auto;
            position: relative;
            z-index: 1;
            border: 1px solid rgba(255,255,255,0.05); /* Subtle border */
        }

        h1 {
            color: var(--text-primary);
            text-shadow: 0 0 12px var(--shadow-color-light);
            margin-bottom: 0.2rem;
            font-size: 2.2rem;
            font-weight: 700;
        }

        .game-info {
            display: flex;
            justify-content: space-around; /* Better spacing for scores */
            width: 100%;
            font-size: 1.5rem;
            font-weight: 600; /* Slightly bolder */
            color: var(--text-primary);
            padding: 0 0.5rem;
        }
        .game-info span {
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
        }
        #player1-score { color: var(--accent-primary); }
        #player2-score { color: var(--accent-danger); }

        .rally-counter {
            font-size: 1.2rem;
            color: var(--text-secondary);
            text-align: center;
            width: 100%;
            margin-top: -0.25rem;
            font-weight: 500;
        }

        .controls-main, .controls-settings {
            display: flex;
            gap: 0.8rem;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        .controls-settings {
            margin-top: 0.25rem;
            align-items: center;
        }
         .controls-settings label {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-secondary);
         }

        button, select {
            background: linear-gradient(145deg, var(--accent-primary), color-mix(in srgb, var(--accent-primary) 80%, black));
            color: white;
            border: none;
            padding: 0.75rem 1.35rem;
            border-radius: 0.6rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 -2px 1px rgba(0,0,0,0.1);
            outline: none;
            position: relative;
            overflow: hidden;
            display: inline-flex; /* For icon alignment */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
        }
        button i { line-height: 1; } /* Ensure icon aligns well */

        select {
            padding: 0.75rem 1rem;
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23a0aec0'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E"); /* Custom arrow */
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1.2em;
        }

        button:hover, select:hover {
            background: linear-gradient(145deg, color-mix(in srgb, var(--accent-primary) 120%, white), var(--accent-primary));
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3), inset 0 -1px 0px rgba(0,0,0,0.05);
        }

        button:active, select:active {
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.25), inset 0 -2px 1px rgba(0,0,0,0.15);
        }

        /* Specific button colors */
        #resetButton {
             background: linear-gradient(145deg, var(--accent-danger), color-mix(in srgb, var(--accent-danger) 80%, black));
        }
        #resetButton:hover {
            background: linear-gradient(145deg, color-mix(in srgb, var(--accent-danger) 120%, white), var(--accent-danger));
        }
        select#difficultySelector {
            background: linear-gradient(145deg, var(--accent-secondary), color-mix(in srgb, var(--accent-secondary) 80%, black));
        }
        select#difficultySelector:hover {
            background: linear-gradient(145deg, color-mix(in srgb, var(--accent-secondary) 120%, white), var(--accent-secondary));
        }


        .message-box { /* This is the general game message box, not canvas overlay */
            position: fixed;
            bottom: 20px; /* Position at bottom */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(37, 42, 51, 0.95); /* --bg-secondary with alpha */
            backdrop-filter: blur(3px);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1rem;
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, transform 0.4s ease, visibility 0.4s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transform: translate(-50%, 20px); /* Start off-screen for slide-in */
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%); /* Slide in */
        }


        @media (max-width: 920px) {
            .game-container { width: 95vw; padding: 1rem; }
            h1 { font-size: 2rem; }
            .game-info { font-size: 1.3rem; }
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.7rem; }
            .game-info { font-size: 1rem; flex-direction: column; align-items: center; gap: 0.2rem; }
            .rally-counter { font-size: 0.9rem; }
            .controls-main, .controls-settings { flex-direction: column; align-items: stretch; gap: 0.6rem; }
            button, select { width: 100%; padding: 0.9rem 1rem; font-size: 0.95rem; }
            .controls-settings label { text-align: center; margin-bottom: 0.1rem; font-size: 0.9rem;}
            .canvas-overlay { font-size: 1.8rem; }
            .canvas-overlay .final-score { font-size: 1.2rem; }
            .message-box { width: 90vw; font-size: 0.9rem; padding: 0.6rem 1.2rem; }
        }
        @media (max-height: 480px) and (orientation: landscape) {
            h1 { font-size: 1.3rem; margin-bottom: 0.05rem;}
            .game-info { font-size: 0.8rem; gap: 0.1rem; flex-direction: row; justify-content: space-around;}
            .rally-counter { font-size: 0.75rem; margin-top: -0.15rem; }
            .controls-main, .controls-settings { gap: 0.3rem; flex-direction: row; flex-wrap: nowrap; }
            button, select { font-size: 0.75rem; padding: 0.5rem 0.7rem; white-space: nowrap; gap: 0.3rem;}
            button i { font-size: 0.8em; }
            .controls-settings label { font-size: 0.75rem; margin-right: 0.2rem;}
            .game-container { padding: 0.5rem; gap: 0.4rem;}
            .canvas-overlay { font-size: 1.5rem; }
            .canvas-overlay .final-score { font-size: 1rem; }
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="game-container">
        <h1>Pong Pro</h1>
        <div class="game-info">
            <span id="player1-score">Player: 0</span>
            <span id="player2-score">Computer: 0</span>
        </div>
        <div class="rally-counter">Rally: <span id="rallyCount">0</span></div>

        <div class="game-wrapper">
            <canvas id="pongCanvas"></canvas>
            <div class="canvas-overlay" id="canvasOverlay">
                <span id="overlayMessage"></span>
                <span id="overlaySubMessage" class="final-score"></span>
            </div>
            <div class="touch-controls">
                <div class="touch-area" id="touchUpArea"></div>
                <div class="touch-area" id="touchDownArea"></div>
            </div>
        </div>

        <div class="controls-main">
            <button id="startButton"><i class="fas fa-play"></i>Start</button>
            <button id="pauseButton"><i class="fas fa-pause"></i>Pause</button>
            <button id="resetButton"><i class="fas fa-undo"></i>Reset</button>
        </div>
        <div class="controls-settings">
            <label for="difficultySelector">Difficulty: </label>
            <select id="difficultySelector">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
            </select>
        </div>
    </div>

    <div id="gameMessageBox" class="message-box"></div> {/* Renamed to avoid conflict with canvas message */}

    <script>
        // Canvas elements
        const pongCanvas = document.getElementById('pongCanvas');
        const pongCtx = pongCanvas.getContext('2d');
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');

        // UI Elements
        const player1ScoreDisplay = document.getElementById('player1-score');
        const player2ScoreDisplay = document.getElementById('player2-score');
        const rallyCountDisplay = document.getElementById('rallyCount');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const resetButton = document.getElementById('resetButton');
        const difficultySelector = document.getElementById('difficultySelector');
        const gameMessageBox = document.getElementById('gameMessageBox'); // General game messages
        const canvasOverlay = document.getElementById('canvasOverlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const overlaySubMessage = document.getElementById('overlaySubMessage');

        // Game State
        let gameRunning = false;
        let gamePaused = false;
        let animationFrameId;
        let rallyCount = 0;
        let currentDifficulty = 'medium';

        // Paddle Properties
        const paddleWidth = 12;
        const paddleHeight = 100;
        const playerPaddleSpeed = 7.5; // Slightly faster player
        let aiPaddleSpeed = 5; // Base AI speed

        // Player 1 (Human)
        let player1 = {
            x: 15, // Slightly more offset
            y: pongCanvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0,
            score: 0,
            hitEffect: 0,
            color1: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
            color2: colorMix(getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(), '#000000', 0.7)
        };

        // Player 2 (AI)
        let player2 = {
            x: pongCanvas.width - paddleWidth - 15, // Slightly more offset
            y: pongCanvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0,
            score: 0,
            hitEffect: 0,
            color1: getComputedStyle(document.documentElement).getPropertyValue('--accent-danger').trim(),
            color2: colorMix(getComputedStyle(document.documentElement).getPropertyValue('--accent-danger').trim(), '#000000', 0.7)
        };
        
        // Ball Properties
        let ball = {
            x: pongCanvas.width / 2,
            y: pongCanvas.height / 2,
            radius: 9,
            baseSpeedX: 5.8, // Slightly faster base
            baseSpeedY: 5.8,
            dx: 5.8,
            dy: 5.8,
            glowIntensity: 0,
            trail: [],
            color1: '#f6e05e', // Bright yellow center
            color2: '#ecc94b'  // Darker yellow edge
        };
        const MAX_TRAIL_LENGTH = 18; // Longer trail

        // Sound Effects
        const paddleSynth = new Tone.Synth({ oscillator: { type: 'square6' }, volume: -8, envelope: { attack: 0.004, decay: 0.07, sustain: 0.01, release: 0.08 } }).toDestination();
        const wallSynth = new Tone.Synth({ oscillator: { type: 'triangle4' }, volume: -12, envelope: { attack: 0.008, decay: 0.1, sustain: 0.02, release: 0.1 } }).toDestination();
        const scoreSynth = new Tone.MembraneSynth({ pitchDecay: 0.015, octaves: 6, volume: -6, envelope: { attack: 0.001, decay: 0.25, sustain: 0.01 } }).toDestination();
        const pauseSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
        const uiClickSynth = new Tone.Synth({ oscillator: {type: 'sine'}, volume: -15, envelope: {attack: 0.001, decay: 0.05, sustain: 0, release: 0.1}}).toDestination();


        // --- Utility: Color Mixer (basic) ---
        function colorMix(color1, color2, weight) {
            function d2h(d) { return d.toString(16); }
            function h2d(h) { return parseInt(h, 16); }
            weight = (typeof(weight) !== 'undefined') ? weight : 0.5;
            var c1 = color1.replace('#','');
            var c2 = color2.replace('#','');
            var mixed = "#";
            for(var i = 0; i <= 2; i++) {
                var C1 = h2d(c1.substr(i*2,2));
                var C2 = h2d(c2.substr(i*2,2));
                var C = Math.round((C1 * (1-weight)) + (C2 * weight));
                var c = d2h(C);
                while(c.length < 2) { c = "0" + c; }
                mixed += c;
            }
            return mixed;
        }


        // Particle Background
        let particlesArray = [];
        const numberOfParticles = 40;

        class Particle {
            constructor() {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.size = Math.random() * 1.8 + 0.6;
                this.speedX = Math.random() * 0.3 - 0.15;
                this.speedY = Math.random() * 0.3 - 0.15;
                this.color = `rgba(79, 128, 225, ${Math.random() * 0.2 + 0.05})`; // Using accent color
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                if (this.x < 0 || this.x > particleCanvas.width) this.speedX *= -1;
                if (this.y < 0 || this.y > particleCanvas.height) this.speedY *= -1;
            }
            draw() {
                particleCtx.fillStyle = this.color;
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                particleCtx.fill();
            }
        }

        function initParticles() {
            particlesArray = [];
            for (let i = 0; i < numberOfParticles; i++) {
                particlesArray.push(new Particle());
            }
        }

        function handleParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
                particlesArray[i].draw();
            }
        }

        function playSound(synth, note, duration) {
            let scheduledTime = Tone.now() + 0.01; // Define scheduledTime here to use in catch block
            try {
                if (Tone && Tone.context && Tone.context.state !== 'running') {
                    Tone.start().catch(e => {
                        console.error("Error starting Tone.js audio context:", e);
                        // Potentially disable sounds or notify user if context can't start
                    });
                }

                // Ensure the synth is ready for a new sound, especially for rapid re-triggers
                if (typeof synth.triggerRelease === 'function') {
                    // Release any currently playing note on this synth instance.
                    // Schedule this release to happen "now".
                    synth.triggerRelease(Tone.now());
                }

                // Schedule the new note to start slightly in the future.
                // This helps avoid the "Start time must be strictly greater" error.
                synth.triggerAttackRelease(note, duration, scheduledTime);

            } catch (error) {
                let synthName = 'UnknownSynth';
                if (synth === paddleSynth) synthName = 'paddleSynth';
                else if (synth === wallSynth) synthName = 'wallSynth';
                else if (synth === scoreSynth) synthName = 'scoreSynth';
                else if (synth === pauseSynth) synthName = 'pauseSynth';
                else if (synth === uiClickSynth) synthName = 'uiClickSynth';
                // Log detailed error information
                console.error(
                    `Sound error: ${error.message}\n` + // Added newline for better readability in console
                    `Synth: ${synthName}\n` +
                    `Note: ${note}\n` +
                    `Duration: ${duration}\n` +
                    `Context State: ${Tone.context ? Tone.context.state : 'N/A'}\n` +
                    `Tone.now(): ${Tone.now()}\n` +
                    `Scheduled Time: ${scheduledTime}\n`, // Log scheduledTime
                    error.stack // Log the full stack trace
                );
            }
        }


        function showGameMessage(message, duration = 2200) { // For general messages
            gameMessageBox.textContent = message;
            gameMessageBox.classList.add('show');
            if (duration > 0) {
                setTimeout(() => {
                    gameMessageBox.classList.remove('show');
                }, duration);
            }
        }
        function showCanvasMessage(mainText, subText = "", persistent = false) {
            overlayMessage.textContent = mainText;
            overlaySubMessage.textContent = subText;
            canvasOverlay.classList.add('show');
            if (!persistent) {
                setTimeout(() => {
                     if (overlayMessage.textContent === mainText) { // Only hide if it's still the same message
                        hideCanvasMessage();
                     }
                }, 2000); // Default duration for non-persistent canvas messages
            }
        }
        function hideCanvasMessage() {
            canvasOverlay.classList.remove('show');
        }


        function updateScores() {
            player1ScoreDisplay.textContent = `Player: ${player1.score}`;
            player2ScoreDisplay.textContent = `Computer: ${player2.score}`;
            rallyCountDisplay.textContent = rallyCount;
        }

        function setDifficulty(level) {
            currentDifficulty = level;
            switch (level) {
                case 'easy':
                    aiPaddleSpeed = 3.5;
                    ball.baseSpeedX = 5.0;
                    ball.baseSpeedY = 5.0;
                    break;
                case 'medium':
                    aiPaddleSpeed = 5.0;
                    ball.baseSpeedX = 5.8;
                    ball.baseSpeedY = 5.8;
                    break;
                case 'hard':
                    aiPaddleSpeed = 7.5; // AI matches player speed
                    ball.baseSpeedX = 6.8;
                    ball.baseSpeedY = 6.8;
                    break;
            }
            if (!gameRunning && !gamePaused) resetBall();
        }

        function resetBall(scored = false) {
            ball.x = pongCanvas.width / 2;
            ball.y = pongCanvas.height / 2;
            ball.dx = (Math.random() < 0.5 ? 1 : -1) * ball.baseSpeedX;
            // Ensure some vertical movement, not too flat
            let initialDY = (Math.random() * 0.5 + 0.5) * ball.baseSpeedY; // 50% to 100% of base Y speed
            ball.dy = (Math.random() < 0.5 ? 1 : -1) * initialDY;

            ball.glowIntensity = 0;
            ball.trail = [];
            if (!scored) rallyCount = 0;
            updateScores();
        }

        function resetGame() {
            playSound(uiClickSynth, 'C3', '32n');
            gameRunning = false;
            gamePaused = false;
            pauseButton.innerHTML = '<i class="fas fa-pause"></i>Pause';
            cancelAnimationFrame(animationFrameId);
            player1.score = 0;
            player2.score = 0;
            rallyCount = 0;
            updateScores();
            player1.y = pongCanvas.height / 2 - paddleHeight / 2;
            player2.y = pongCanvas.height / 2 - paddleHeight / 2;
            player1.hitEffect = 0;
            player2.hitEffect = 0;
            setDifficulty(difficultySelector.value);
            resetBall();
            hideCanvasMessage();
            draw();
            showGameMessage("Game Reset. Select Difficulty & Start.", 3000);
            startButton.disabled = false;
            difficultySelector.disabled = false;
        }

        function startGame() {
            playSound(uiClickSynth, 'C4', '32n');
            if (!gameRunning) {
                if (Tone && Tone.context && Tone.context.state !== 'running') {
                     Tone.start().then(() => console.log("Audio context started.")).catch(e => console.error("Error starting Tone context in startGame:", e));
                }
                gameRunning = true;
                gamePaused = false;
                hideCanvasMessage();
                showGameMessage("Game Started!", 1500);
                startButton.disabled = true;
                difficultySelector.disabled = true;
                resetBall();
                animate();
            }
        }

        function togglePauseGame() {
            playSound(uiClickSynth, 'G3', '32n');
            if (!gameRunning && !gamePaused) return;

            gamePaused = !gamePaused;
            if (gamePaused) {
                cancelAnimationFrame(animationFrameId);
                showCanvasMessage("PAUSED", "Press 'P' or Resume to continue", true);
                pauseButton.innerHTML = '<i class="fas fa-play"></i>Resume';
                playSound(pauseSynth, 'C3', '8n');
            } else {
                hideCanvasMessage();
                pauseButton.innerHTML = '<i class="fas fa-pause"></i>Pause';
                playSound(pauseSynth, 'G3', '8n');
                animate();
            }
        }

        function drawPaddle(x, y, width, height, color1, color2, hitEffect) {
            const gradient = pongCtx.createLinearGradient(x, y, x + width, y + height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            pongCtx.fillStyle = gradient;
            pongCtx.shadowColor = colorMix(color1, '#FFFFFF', 0.3); // Lighter glow
            pongCtx.shadowBlur = 10 + hitEffect * 15; // More pronounced hit glow
            pongCtx.shadowOffsetX = 0;
            pongCtx.shadowOffsetY = 0;
            pongCtx.fillRect(x, y, width, height);
            pongCtx.shadowBlur = 0; // Reset shadow
        }

        function drawBallAndTrail() {
            // Draw trail
            for (let i = 0; i < ball.trail.length; i++) {
                const pos = ball.trail[i];
                const opacity = (i / ball.trail.length) * 0.35; // Subtler trail
                pongCtx.fillStyle = `rgba(246, 224, 94, ${opacity})`;
                pongCtx.beginPath();
                pongCtx.arc(pos.x, pos.y, ball.radius * (i / ball.trail.length) * 0.7, 0, Math.PI * 2);
                pongCtx.fill();
            }

            // Draw ball
            const gradient = pongCtx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, ball.color1);
            gradient.addColorStop(0.8, ball.color2); // Sharper gradient
            pongCtx.fillStyle = gradient;

            pongCtx.shadowColor = ball.color1;
            pongCtx.shadowBlur = 12 * ball.glowIntensity + 5; // Base glow + pulse
            pongCtx.beginPath();
            pongCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            pongCtx.fill();
            pongCtx.shadowBlur = 0;
        }

        function drawNet() {
            pongCtx.strokeStyle = 'rgba(160, 174, 192, 0.3)'; // --text-secondary with alpha
            pongCtx.setLineDash([7, 12]); // More stylized dashes
            pongCtx.lineWidth = 2.5;
            pongCtx.beginPath();
            pongCtx.moveTo(pongCanvas.width / 2, 0);
            pongCtx.lineTo(pongCanvas.width / 2, pongCanvas.height);
            pongCtx.stroke();
            pongCtx.setLineDash([]);
            pongCtx.lineWidth = 1;
        }

        function draw() {
            pongCtx.clearRect(0, 0, pongCanvas.width, pongCanvas.height);
            drawNet();
            drawPaddle(player1.x, player1.y, player1.width, player1.height, player1.color1, player1.color2, player1.hitEffect);
            drawPaddle(player2.x, player2.y, player2.width, player2.height, player2.color1, player2.color2, player2.hitEffect);
            drawBallAndTrail();
        }

        function update() {
            if (gamePaused) return;

            player1.y += player1.dy;

            // AI Logic
            if (ball.dx > 0) { // AI moves when ball is on its half or approaching
                const paddleCenter = player2.y + player2.height / 2;
                const targetY = ball.y;
                // Add some imperfection/prediction based on difficulty
                let reactionOffset = 0; // How far the ball must be from center for AI to react
                let predictionError = 0; // How much AI misjudges ball's final Y
                if (currentDifficulty === 'easy') { reactionOffset = 35; predictionError = Math.random() * 40 - 20; }
                if (currentDifficulty === 'medium') { reactionOffset = 20; predictionError = Math.random() * 25 - 12.5; }
                // Hard AI has minimal error

                if (paddleCenter < targetY + predictionError - reactionOffset) player2.dy = aiPaddleSpeed;
                else if (paddleCenter > targetY + predictionError + reactionOffset) player2.dy = -aiPaddleSpeed;
                else player2.dy = 0;
            } else { // Ball moving away from AI
                const centerOfCanvas = pongCanvas.height / 2;
                const paddleCenter = player2.y + player2.height / 2;
                if (paddleCenter < centerOfCanvas - 15) player2.dy = aiPaddleSpeed * 0.6; // Slower recentering
                else if (paddleCenter > centerOfCanvas + 15) player2.dy = -aiPaddleSpeed * 0.6;
                else player2.dy = 0;
            }
            player2.y += player2.dy;


            player1.y = Math.max(0, Math.min(pongCanvas.height - player1.height, player1.y));
            player2.y = Math.max(0, Math.min(pongCanvas.height - player2.height, player2.y));

            ball.x += ball.dx;
            ball.y += ball.dy;

            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > MAX_TRAIL_LENGTH) ball.trail.shift();

            ball.glowIntensity = Math.sin(Date.now() * 0.006) * 0.5 + 0.5; // Sine wave for pulsing
            player1.hitEffect = Math.max(0, player1.hitEffect - 0.035); // Slower fade for hit effect
            player2.hitEffect = Math.max(0, player2.hitEffect - 0.035);

            // Ball collision with top/bottom walls
            if (ball.y + ball.radius > pongCanvas.height || ball.y - ball.radius < 0) {
                ball.dy *= -1;
                playSound(wallSynth, 'D2', '24n');
                ball.y = (ball.y - ball.radius < 0) ? ball.radius : pongCanvas.height - ball.radius; // Prevent sticking
            }

            // Ball collision with paddles
            let hit = false;
            let hitSpeedMultiplier = 1.025; // Base speed increase on hit
            // Player 1
            if (ball.dx < 0 && ball.x - ball.radius < player1.x + player1.width && ball.x - ball.radius > player1.x &&
                ball.y + ball.radius > player1.y && ball.y - ball.radius < player1.y + player1.height) {
                hit = true;
                player1.hitEffect = 1;
            }
            // Player 2
            else if (ball.dx > 0 && ball.x + ball.radius > player2.x && ball.x + ball.radius < player2.x + player2.width &&
                ball.y + ball.radius > player2.y && ball.y - ball.radius < player2.y + player2.height) {
                hit = true;
                player2.hitEffect = 1;
                if (currentDifficulty === 'hard') hitSpeedMultiplier = 1.035; // Hard AI hits harder
            }

            if (hit) {
                ball.dx *= -hitSpeedMultiplier;
                // Make speeds absolute before capping, then reapply sign
                let currentSpeedXAbs = Math.abs(ball.dx);
                let currentSpeedYAbs = Math.abs(ball.dy);
                const maxSpeed = ball.baseSpeedX * 2.5; // Max speed cap
                ball.dx = Math.sign(ball.dx) * Math.min(currentSpeedXAbs, maxSpeed);

                let hitSpot = (ball.y - (ball.dx > 0 ? player1.y : player2.y)) / paddleHeight; // 0 to 1
                hitSpot = Math.max(0.05, Math.min(0.95, hitSpot));
                let angleFactor = (currentDifficulty === 'hard') ? 12 : 10; // How much angle is imparted
                let newDy = (hitSpot - 0.5) * angleFactor;

                // Add a portion of existing dy to newDy to make it feel more natural
                ball.dy = newDy * 0.7 + ball.dy * 0.3;
                ball.dy = Math.sign(ball.dy) * Math.min(Math.abs(ball.dy), ball.baseSpeedY * 1.8); // Cap vertical speed


                playSound(paddleSynth, 'C4', '24n');
                rallyCount++;
                updateScores();
                ball.x = (ball.dx < 0) ? player2.x - ball.radius -1 : player1.x + player1.width + ball.radius + 1;
            }


            // Scoring
            const WINNING_SCORE = 5;
            if (ball.x - ball.radius < -20) { // Player 2 scores
                player2.score++;
                playSound(scoreSynth, 'E2', '8n');
                resetBall(true);
                if (player2.score >= WINNING_SCORE) {
                    showCanvasMessage("COMPUTER WINS!", `${player1.score} - ${player2.score}`, true);
                    endGame();
                } else {
                    showGameMessage("Computer Scored!", 1500);
                }
            } else if (ball.x + ball.radius > pongCanvas.width + 20) { // Player 1 scores
                player1.score++;
                playSound(scoreSynth, 'A2', '8n');
                resetBall(true);
                if (player1.score >= WINNING_SCORE) {
                    showCanvasMessage("PLAYER WINS!", `${player1.score} - ${player2.score}`, true);
                    endGame();
                } else {
                    showGameMessage("Player Scored!", 1500);
                }
            }
            updateScores();
        }

        function endGame() {
            gameRunning = false;
            gamePaused = false;
            cancelAnimationFrame(animationFrameId);
            startButton.disabled = false;
            difficultySelector.disabled = false;
        }

        function animate() {
            if (gameRunning && !gamePaused) {
                update();
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }
            handleParticles();
            if (!gameRunning && !gamePaused && !canvasOverlay.classList.contains('show')) { // Keep particles if game stopped but no persistent overlay
                 requestAnimationFrame(animate);
            } else if (canvasOverlay.classList.contains('show')) { // If overlay is shown (paused/game over), still draw particles once
                 handleParticles(); // Then stop requesting frames if game not running
            }
        }


        function handleKeyDown(event) {
            if (event.key === 'Enter' && !gameRunning && !gamePaused) startGame();
            else if (event.key.toLowerCase() === 'r') resetGame();
            else if (event.key.toLowerCase() === 'p' && (gameRunning || gamePaused)) togglePauseGame();

            if (!gamePaused && gameRunning) {
                switch (event.key.toLowerCase()) {
                    case 'w': player1.dy = -playerPaddleSpeed; break;
                    case 's': player1.dy = playerPaddleSpeed; break;
                }
            }
        }
        function handleKeyUp(event) {
            if (!gamePaused && gameRunning) {
                switch (event.key.toLowerCase()) {
                    case 'w': case 's': player1.dy = 0; break;
                }
            }
        }

        function handleTouchStart(event) {
            event.preventDefault();
            if (Tone && Tone.context && Tone.context.state !== 'running') {
                 Tone.start().then(() => {}).catch(e => console.error("Error starting Tone context in touchStart:", e));
            }
            if (!gameRunning || gamePaused) return;
            const touch = event.touches[0];
            const rect = pongCanvas.getBoundingClientRect();
            if (touch.clientX - rect.left < pongCanvas.width / 2) { // Touch on left half for player1
                 if (touch.clientY - rect.top < pongCanvas.height / 2) player1.dy = -playerPaddleSpeed;
                 else player1.dy = playerPaddleSpeed;
            }
        }
        function handleTouchMove(event) {
            event.preventDefault();
            if (!gameRunning || gamePaused) return;
            const touch = event.touches[0];
            const rect = pongCanvas.getBoundingClientRect();
            if (touch.clientX - rect.left < pongCanvas.width / 2) {
                if (touch.clientY - rect.top < pongCanvas.height / 2) player1.dy = -playerPaddleSpeed;
                else player1.dy = playerPaddleSpeed;
            }
        }
        function handleTouchEnd(event) {
            event.preventDefault();
            player1.dy = 0;
        }

        function resizeGame() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            if(particlesArray.length > 0 || gameRunning || gamePaused) initParticles();


            const gameContainerStyle = getComputedStyle(document.querySelector('.game-container'));
            const containerPaddingVertical = parseFloat(gameContainerStyle.paddingTop) + parseFloat(gameContainerStyle.paddingBottom);

            const controlsMainHeight = document.querySelector('.controls-main').offsetHeight;
            const controlsSettingsHeight = document.querySelector('.controls-settings').offsetHeight;
            const h1Height = document.querySelector('h1').offsetHeight;
            const gameInfoHeight = document.querySelector('.game-info').offsetHeight;
            const rallyCounterHeight = document.querySelector('.rally-counter').offsetHeight;
            const gameWrapperMarginBottom = parseFloat(getComputedStyle(document.querySelector('.game-wrapper')).marginBottom);

            const totalNonCanvasHeight = controlsMainHeight + controlsSettingsHeight + h1Height + gameInfoHeight + rallyCounterHeight + containerPaddingVertical + gameWrapperMarginBottom + 60; // 60 for various gaps
            let maxCanvasHeight = window.innerHeight - totalNonCanvasHeight;

            let newWidth = maxCanvasHeight * (16 / 9);
            let newHeight = maxCanvasHeight;

            const gameWrapper = document.querySelector('.game-wrapper');
            let maxCanvasWidth = gameWrapper.clientWidth;

            if (newWidth > maxCanvasWidth) {
                newWidth = maxCanvasWidth;
                newHeight = newWidth / (16 / 9);
            }
            if (newHeight > maxCanvasHeight && maxCanvasHeight > 0) {
                 newHeight = maxCanvasHeight;
                 newWidth = newHeight * (16/9);
            }

            newWidth = Math.max(160, newWidth); // Minimum reasonable width
            newHeight = Math.max(90, newHeight); // Minimum reasonable height

            pongCanvas.style.width = `${newWidth}px`;
            pongCanvas.style.height = `${newHeight}px`;
            pongCanvas.width = newWidth;
            pongCanvas.height = newHeight;

            player1.x = 15;
            player1.y = pongCanvas.height / 2 - player1.height / 2;
            player2.x = pongCanvas.width - player2.width - 15;
            player2.y = pongCanvas.height / 2 - player2.height / 2;

            if (!gameRunning) resetBall();
            draw();
            if (gamePaused) { // If paused during resize, re-show pause message
                 showCanvasMessage("PAUSED", "Press 'P' or Resume to continue", true);
            }
        }

        // Event Listeners
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', resizeGame);

        pongCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        pongCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        pongCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        pongCanvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        startButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', togglePauseGame);
        resetButton.addEventListener('click', resetGame);
        difficultySelector.addEventListener('change', (e) => {
            playSound(uiClickSynth, 'F3', '32n');
            setDifficulty(e.target.value);
            if(!gameRunning && !gamePaused) {
                resetBall();
                draw();
            }
        });

        // Initial Setup
        window.onload = function() {
            // Update paddle colors based on CSS variables after they are defined
            player1.color1 = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
            player1.color2 = colorMix(player1.color1, '#000000', 0.7);
            player2.color1 = getComputedStyle(document.documentElement).getPropertyValue('--accent-danger').trim();
            player2.color2 = colorMix(player2.color1, '#000000', 0.7);

            setDifficulty(difficultySelector.value);
            initParticles();
            resizeGame();
            resetGame(); // This will show initial message
            animate();
        };
    </script>
</body>
</html>
