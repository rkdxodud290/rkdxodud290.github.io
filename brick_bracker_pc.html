<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Breaker - Upgraded!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .container {
            text-align: center;
            background-color: #2a2a2a;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }
        canvas {
            background: #000;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }
        h1 {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        #infoPanel {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            margin-top: 1rem;
            padding: 0 1rem;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2rem 3rem;
            border-radius: 1rem;
            text-align: center;
            border: 2px solid #00ffff;
            z-index: 10;
        }
        #messageBox h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        #restartButton {
            font-family: 'Press Start 2P', cursive;
            background-color: #00ffff;
            color: #1a1a1a;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        #restartButton:hover {
            background-color: #fff;
            box-shadow: 0 0 15px #fff;
        }

        /* Power-up styles */
        .powerup {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: gold; /* Default for now */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            color: black;
            font-weight: bold;
        }
        .powerup-expand { background-color: #54ff40; } /* Green */
        .powerup-fast { background-color: #ff3838; } /* Red */
        .powerup-life { background-color: #00ffff; } /* Cyan */
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center h-screen">

    <div class="container mx-auto p-4 md:p-8 rounded-lg shadow-2xl">
        <h1 class="text-4xl md:text-5xl mb-4">Brick Breaker</h1>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="infoPanel" class="text-lg mt-4">
            <span id="score">Score: 0</span>
            <span id="lives">Lives: 3</span>
            <span id="level">Level: 1</span>
        </div>
    </div>

    <div id="messageBox" class="hidden">
        <h2 id="messageText">Game Over</h2>
        <button id="restartButton">Restart</button>
    </div>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- DOM Elements ---
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        // --- Game State & Constants ---
        let score = 0;
        let lives = 3;
        let level = 1;
        let rightPressed = false;
        let leftPressed = false;
        let gameRunning = true;
        let animationFrameId; // To store the requestAnimationFrame ID

        const MAX_LEVELS = 3; // Define total number of levels

        // --- Ball Properties ---
        const ball = {
            x: canvas.width / 2,
            y: canvas.height - 30,
            dx: 4,
            dy: -4,
            initialDx: 4, // Store initial speed
            initialDy: -4,
            radius: 10,
            color: '#00ffff',
            isStuck: true // Ball starts stuck to the paddle
        };

        // --- Paddle Properties ---
        const paddle = {
            height: 15,
            width: 120,
            initialWidth: 120, // Store initial width
            x: (canvas.width - 120) / 2,
            speed: 7,
            color: '#ff00ff'
        };

        // --- Brick Properties ---
        const brick = {
            rowCount: 5,
            columnCount: 9,
            width: 75,
            height: 20,
            padding: 10,
            offsetTop: 40,
            offsetLeft: 30,
            colors: ['#ff3838', '#ff9f1a', '#fff200', '#54ff40', '#3498db']
        };

        // --- Power-up Properties ---
        let powerUps = [];
        const POWERUP_TYPES = {
            EXPAND_PADDLE: 'expand_paddle',
            FAST_BALL: 'fast_ball',
            EXTRA_LIFE: 'extra_life'
        };
        const POWERUP_DROP_CHANCE = 0.15; // 15% chance for a power-up to drop

        // --- Brick Layouts for Levels ---
        const levelsData = [
            // Level 1
            [
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1]
            ],
            // Level 2 (More gaps, different pattern)
            [
                [0,1,1,1,1,1,1,1,0],
                [1,0,1,1,1,1,1,0,1],
                [1,1,0,1,1,1,0,1,1],
                [1,1,1,0,1,0,1,1,1],
                [1,1,1,1,0,1,1,1,1]
            ],
            // Level 3 (Harder, more gaps)
            [
                [0,0,1,1,1,1,1,0,0],
                [0,1,0,1,1,1,0,1,0],
                [1,0,1,0,1,0,1,0,1],
                [1,1,0,1,0,1,0,1,1],
                [1,1,1,0,1,0,1,1,1]
            ]
        ];

        // --- Brick Array Initialization ---
        let bricks = [];

        function initBricksForLevel(levelNum) {
            bricks = [];
            const currentLevelLayout = levelsData[levelNum - 1]; // levelsData is 0-indexed

            for (let c = 0; c < brick.columnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brick.rowCount; r++) {
                    bricks[c][r] = {
                        x: 0,
                        y: 0,
                        status: currentLevelLayout[r][c], // Use level layout for status
                        color: brick.colors[r]
                    };
                }
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', keyDownHandler, false);
        document.addEventListener('keyup', keyUpHandler, false);
        document.addEventListener('mousemove', mouseMoveHandler, false);
        restartButton.addEventListener('click', restartGame);
        canvas.addEventListener('click', releaseBall, false); // Click to release ball

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        function mouseMoveHandler(e) {
            const relativeX = e.clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < canvas.width) {
                paddle.x = relativeX - paddle.width / 2;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

                if (ball.isStuck) {
                    ball.x = paddle.x + paddle.width / 2; // Ball stays centered on paddle
                }
            }
        }

        function releaseBall() {
            if (ball.isStuck && gameRunning) {
                ball.isStuck = false;
            }
        }

        // --- Collision Detection ---
        function collisionDetection() {
            for (let c = 0; c < brick.columnCount; c++) {
                for (let r = 0; r < brick.rowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        // Check if the ball's center is inside the brick
                        if (
                            ball.x > b.x &&
                            ball.x < b.x + brick.width &&
                            ball.y > b.y &&
                            ball.y < b.y + brick.height
                        ) {
                            ball.dy = -ball.dy; // Reverse vertical direction
                            b.status = 0; // "Break" the brick
                            score += 10; // Increased score for breaking a brick
                            updateInfoPanel();

                            // Drop a power-up
                            if (Math.random() < POWERUP_DROP_CHANCE) {
                                dropPowerUp(b.x + brick.width / 2, b.y + brick.height / 2);
                            }

                            // Check for win condition for current level
                            let allBricksBroken = true;
                            for (let col = 0; col < brick.columnCount; col++) {
                                for (let row = 0; row < brick.rowCount; row++) {
                                    if (bricks[col][row].status === 1) {
                                        allBricksBroken = false;
                                        break;
                                    }
                                }
                                if (!allBricksBroken) break;
                            }

                            if (allBricksBroken) {
                                if (level < MAX_LEVELS) {
                                    level++;
                                    showMessage(`LEVEL ${level}!`);
                                    resetForNextLevel();
                                } else {
                                    showMessage('YOU WIN THE GAME!');
                                    gameRunning = false;
                                    cancelAnimationFrame(animationFrameId);
                                }
                            }
                        }
                    }
                }
            }
        }

        function dropPowerUp(x, y) {
            const types = Object.values(POWERUP_TYPES);
            const randomType = types[Math.floor(Math.random() * types.length)];
            powerUps.push({
                x: x,
                y: y,
                radius: 10,
                type: randomType,
                color: getPowerUpColor(randomType),
                dy: 2 // Speed at which power-up falls
            });
        }

        function getPowerUpColor(type) {
            switch (type) {
                case POWERUP_TYPES.EXPAND_PADDLE: return '#54ff40'; // Green
                case POWERUP_TYPES.FAST_BALL: return '#ff3838'; // Red
                case POWERUP_TYPES.EXTRA_LIFE: return '#00ffff'; // Cyan
                default: return 'gold';
            }
        }

        function applyPowerUp(type) {
            switch (type) {
                case POWERUP_TYPES.EXPAND_PADDLE:
                    paddle.width += 30; // Increase paddle width
                    if (paddle.width > canvas.width - 20) paddle.width = canvas.width - 20; // Cap width
                    setTimeout(() => paddle.width = paddle.initialWidth, 7000); // Revert after 7 seconds
                    break;
                case POWERUP_TYPES.FAST_BALL:
                    ball.dx *= 1.3;
                    ball.dy *= 1.3;
                    setTimeout(() => {
                        ball.dx = ball.initialDx;
                        ball.dy = ball.initialDy;
                    }, 5000); // Revert after 5 seconds
                    break;
                case POWERUP_TYPES.EXTRA_LIFE:
                    lives++;
                    updateInfoPanel();
                    break;
            }
        }

        // --- Drawing Functions ---
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            // Add a glow effect
            ctx.shadowColor = ball.color;
            ctx.shadowBlur = 15;
            ctx.closePath();
            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
            ctx.fillStyle = paddle.color;
            ctx.fill();
            // Add a glow effect
            ctx.shadowColor = paddle.color;
            ctx.shadowBlur = 15;
            ctx.closePath();
            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawBricks() {
            for (let c = 0; c < brick.columnCount; c++) {
                for (let r = 0; r < brick.rowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brick.width + brick.padding) + brick.offsetLeft;
                        const brickY = r * (brick.height + brick.padding) + brick.offsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brick.width, brick.height);
                        ctx.fillStyle = bricks[c][r].color;
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.closePath();

                // Add text for power-up type (optional, for debugging/clarity)
                ctx.fillStyle = 'black';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let text = '';
                if (p.type === POWERUP_TYPES.EXPAND_PADDLE) text = 'W'; // Width
                else if (p.type === POWERUP_TYPES.FAST_BALL) text = 'F'; // Fast
                else if (p.type === POWERUP_TYPES.EXTRA_LIFE) text = 'L'; // Life
                ctx.fillText(text, p.x, p.y);
            });
        }

        function updateInfoPanel() {
            scoreEl.textContent = `Score: ${score}`;
            livesEl.textContent = `Lives: ${lives}`;
            levelEl.textContent = `Level: ${level}`;
        }
        
        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        // --- Main Game Loop ---
        function draw() {
            if (!gameRunning) {
                return;
            }

            // Clear the canvas for the next frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw all game elements
            drawBricks();
            drawBall();
            drawPaddle();
            drawPowerUps(); // Draw power-ups
            collisionDetection();

            // --- Ball Movement & Wall Collision Logic ---

            if (!ball.isStuck) {
                // Right/Left wall collision
                if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                    ball.dx = -ball.dx;
                }

                // Top wall collision
                if (ball.y + ball.dy < ball.radius) {
                    ball.dy = -ball.dy;
                }
                // Bottom wall / paddle collision
                else if (ball.y + ball.dy > canvas.height - ball.radius - paddle.height) { // Check slightly above paddle
                    // Check if it hits the paddle
                    if (ball.x > paddle.x && ball.x < paddle.x + paddle.width &&
                        ball.y + ball.radius > canvas.height - paddle.height) { // Ensure ball hits paddle's top
                        
                        ball.dy = -ball.dy;
                        
                        // Add angle reflection based on where ball hits paddle
                        const hitPoint = ball.x - (paddle.x + paddle.width / 2);
                        ball.dx = hitPoint * 0.1; // Adjust this multiplier for desired angle change
                    } else if (ball.y + ball.dy > canvas.height - ball.radius) { // Ball went below paddle
                        lives--;
                        updateInfoPanel();
                        if (!lives) {
                            showMessage('GAME OVER');
                            gameRunning = false;
                            cancelAnimationFrame(animationFrameId); // Stop the animation loop
                        } else {
                            // Reset ball and paddle position
                            ball.isStuck = true; // Ball sticks to paddle after losing a life
                            ball.x = paddle.x + paddle.width / 2;
                            ball.y = canvas.height - 30;
                            ball.dx = ball.initialDx; // Reset ball speed
                            ball.dy = ball.initialDy;
                            paddle.width = paddle.initialWidth; // Reset paddle width
                        }
                    }
                }

                // Update ball position
                ball.x += ball.dx;
                ball.y += ball.dy;
            }


            // --- Paddle Movement Logic ---
            if (rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += paddle.speed;
            } else if (leftPressed && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }

            // If ball is stuck, ensure it follows the paddle
            if (ball.isStuck) {
                ball.x = paddle.x + paddle.width / 2;
            }

            // --- Power-up Movement and Collision ---
            for (let i = 0; i < powerUps.length; i++) {
                const p = powerUps[i];
                p.y += p.dy;

                // Check collision with paddle
                if (p.y + p.radius > canvas.height - paddle.height &&
                    p.x > paddle.x &&
                    p.x < paddle.x + paddle.width) {
                    
                    applyPowerUp(p.type);
                    powerUps.splice(i, 1); // Remove power-up
                    i--;
                } else if (p.y - p.radius > canvas.height) {
                    // Power-up fell off screen
                    powerUps.splice(i, 1);
                    i--;
                }
            }

            // Request the next frame
            animationFrameId = requestAnimationFrame(draw);
        }
        
        // --- Game Management Functions ---
        function resetGame() {
            messageBox.classList.add('hidden');
            score = 0;
            lives = 3;
            level = 1;
            powerUps = []; // Clear power-ups
            initBricksForLevel(level);
            updateInfoPanel();
            
            // Reset ball and paddle
            ball.isStuck = true; // Ball starts stuck
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 30;
            ball.dx = ball.initialDx;
            ball.dy = ball.initialDy;
            paddle.x = (canvas.width - paddle.initialWidth) / 2;
            paddle.width = paddle.initialWidth;

            gameRunning = true;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Clear any existing animation frame
            }
            draw();
        }

        function restartGame() {
            resetGame();
        }

        function resetForNextLevel() {
            powerUps = []; // Clear power-ups for the new level
            initBricksForLevel(level);
            updateInfoPanel();

            // Reset ball and paddle
            ball.isStuck = true; // Ball sticks to paddle for new level
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 30;
            ball.dx = ball.initialDx; // Reset ball speed for new level
            ball.dy = ball.initialDy;
            paddle.x = (canvas.width - paddle.initialWidth) / 2;
            paddle.width = paddle.initialWidth;

            gameRunning = true;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            draw();
        }

        // --- Initial Game Start ---
        resetGame(); // Start the game fresh
    </script>
</body>
</html>
