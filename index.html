<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mine Tycoon - Prestige Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebase App (the core Firebase SDK) is always required and must be listed first
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'mine-tycoon-default';
        
        let app;
        let auth;
        let db;
        let userId = null;
        let isAuthReady = false;
        let gameSaveUnsubscribe = null; 
        let marketUpdateInterval = null;

        // --- Game Object ---
        const Game = {
            state: {}, 
            achievementsList: {}, 
            investableAssets: {},
            prestigeUpgradeDefinitions: {}, // For easy access to definitions

            // --- Initialization ---
            async init() {
                this.achievementsList = this.getAchievementDefinitions(); 
                this.investableAssets = this.getInvestableAssetsDefinition();
                this.prestigeUpgradeDefinitions = this.getPrestigeUpgradeDefinitions(); // Initialize prestige upgrade definitions
                this.state = this.getDefaultState(); 
                document.getElementById('loading-message').classList.remove('hidden');
                try {
                    if (Object.keys(firebaseConfig).length > 0) {
                        app = initializeApp(firebaseConfig);
                        auth = getAuth(app);
                        db = getFirestore(app);
                        setLogLevel('debug'); 

                        await setPersistence(auth, browserLocalPersistence); 

                        onAuthStateChanged(auth, async (user) => {
                            if (user) {
                                userId = user.uid;
                                console.log("User is signed in with UID:", userId);
                                const userIdDisplaySettings = document.getElementById('user-id-display-settings');
                                if (userIdDisplaySettings) userIdDisplaySettings.textContent = userId;
                                isAuthReady = true;
                                await this.loadGame(); 
                            } else {
                                console.log("User is not signed in. Attempting sign-in.");
                                const userIdDisplaySettings = document.getElementById('user-id-display-settings');
                                if (userIdDisplaySettings) userIdDisplaySettings.textContent = 'N/A (Not Signed In)';
                                try {
                                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                        await signInWithCustomToken(auth, __initial_auth_token);
                                    } else {
                                        await signInAnonymously(auth);
                                    }
                                } catch (error) {
                                    console.error("Error during sign-in:", error);
                                    isAuthReady = true; 
                                    this.resetState(false); // Ensure it's a non-prestige reset
                                    this.render();
                                    document.getElementById('loading-message').classList.add('hidden');
                                }
                            }
                        });
                    } else {
                        console.warn("Firebase config is empty. Game will run in offline mode without saving.");
                        const userIdDisplaySettings = document.getElementById('user-id-display-settings');
                        if (userIdDisplaySettings) userIdDisplaySettings.textContent = 'N/A (Offline Mode)';
                        isAuthReady = true; 
                        this.resetState(false); // Ensure it's a non-prestige reset
                        this.calculateOfflineProgression(Date.now()); 
                        this.render();
                        document.getElementById('loading-message').classList.add('hidden');
                    }
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    const userIdDisplaySettings = document.getElementById('user-id-display-settings');
                    if (userIdDisplaySettings) userIdDisplaySettings.textContent = 'N/A (Error)';
                    isAuthReady = true; 
                    this.resetState(false); // Ensure it's a non-prestige reset
                    this.calculateOfflineProgression(Date.now()); 
                    this.render();
                    document.getElementById('loading-message').classList.add('hidden');
                }

                this.setupEventListeners();
                this.startMarketUpdates(); 
                setInterval(() => this.update(), 1000); 
                setInterval(() => this.autoSaveGame(), 30000); 
            },

            getAchievementDefinitions() {
                 return {
                    // Mining Milestones
                    mine_1k_stone: { name: "Stone Digger", description: "Mine 1,000 Stone.", category: "Mining", condition: () => this.state.resources.stone.count >= 1000 },
                    mine_100k_stone: { name: "Stone Miner", description: "Mine 100,000 Stone.", category: "Mining", condition: () => this.state.resources.stone.count >= 100000 },
                    mine_10m_stone: { name: "Stone Tycoon", description: "Mine 10,000,000 Stone.", category: "Mining", condition: () => this.state.resources.stone.count >= 10000000 },
                    mine_10k_coal: { name: "Coal Collector", description: "Mine 10,000 Coal.", category: "Mining", condition: () => this.state.resources.coal.count >= 10000 },
                    mine_1k_iron: { name: "Iron Baron", description: "Mine 1,000 Iron.", category: "Mining", condition: () => this.state.resources.iron.count >= 1000 },
                    mine_5k_copper: { name: "Copper Collector", description: "Mine 5,000 Copper.", category: "Mining", condition: () => this.state.resources.copper.count >= 5000 },
                    mine_1k_quartz: { name: "Quartz Quarryman", description: "Mine 1,000 Quartz.", category: "Mining", condition: () => this.state.resources.quartz?.count >= 1000 },
                    mine_100_gold: { name: "Gold Hoarder", description: "Mine 100 Gold.", category: "Mining", condition: () => this.state.resources.gold.count >= 100 },
                    mine_10_diamond: { name: "Diamond King", description: "Mine 10 Diamond.", category: "Mining", condition: () => this.state.resources.diamond.count >= 10 },
                    mine_10_platinum: { name: "Platinum Prospector", description: "Mine 10 Platinum.", category: "Mining", condition: () => this.state.resources.platinum.count >= 10 },
                    mine_10_emerald: { name: "Emerald Enthusiast", description: "Mine 10 Emeralds.", category: "Mining", condition: () => this.state.resources.emerald.count >= 10 },
                    mine_10_ruby: { name: "Ruby Rover", description: "Mine 10 Rubies.", category: "Mining", condition: () => this.state.resources.ruby.count >= 10 },
                    mine_10_sapphire: { name: "Sapphire Seeker", description: "Mine 10 Sapphires.", category: "Mining", condition: () => this.state.resources.sapphire.count >= 10 },
                    mine_10_amethyst: { name: "Amethyst Hunter", description: "Mine 10 Amethysts.", category: "Mining", condition: () => this.state.resources.amethyst.count >= 10 },
                    mine_obsidian_master: { name: "Obsidian Carver", description: "Mine 1,000 Obsidian.", category: "Mining", condition: () => this.state.resources.obsidian.count >= 1000 },
                    mine_mythril_adept: { name: "Mythril Adept", description: "Mine 500 Mythril.", category: "Mining", condition: () => this.state.resources.mythril?.count >= 500 },
                    mine_orichalcum_lord: { name: "Orichalcum Lord", description: "Mine 100 Orichalcum.", category: "Mining", condition: () => this.state.resources.orichalcum?.count >= 100 },
                    mine_element_x: { name: "X Marks the Spot", description: "Mine your first Element X.", category: "Mining", condition: () => this.state.resources.element_x?.count >= 1 },

                    // Wealth Milestones
                    wealth_1k: { name: "Pocket Change", description: "Earn $1,000 total.", category: "Wealth", condition: () => this.state.money >= 1000 },
                    wealth_100k: { name: "Well Off", description: "Earn $100,000 total.", category: "Wealth", condition: () => this.state.money >= 100000 },
                    wealth_1m: { name: "Millionaire", description: "Earn $1,000,000 total.", category: "Wealth", condition: () => this.state.money >= 1000000 },
                    wealth_1b: { name: "Billionaire", description: "Earn $1,000,000,000 total.", category: "Wealth", condition: () => this.state.money >= 1000000000 },
                    wealth_1t: { name: "Trillionaire", description: "Earn $1,000,000,000,000 total.", category: "Wealth", condition: () => this.state.money >= 1000000000000 },

                    // Progression Milestones
                    unlock_coal: { name: "Getting Started", description: "Unlock Coal.", category: "Progression", condition: () => this.state.resources.coal.unlocked },
                    unlock_iron: { name: "Industrialist", description: "Unlock Iron.", category: "Progression", condition: () => this.state.resources.iron.unlocked },
                    unlock_copper: { name: "Copper Age", description: "Unlock Copper.", category: "Progression", condition: () => this.state.resources.copper.unlocked },
                    unlock_quartz: { name: "Crystal Clear", description: "Unlock Quartz.", category: "Progression", condition: () => this.state.resources.quartz?.unlocked },
                    unlock_gold: { name: "Prospector", description: "Unlock Gold.", category: "Progression", condition: () => this.state.resources.gold.unlocked },
                    unlock_diamond: { name: "Gemologist", description: "Unlock Diamond.", category: "Progression", condition: () => this.state.resources.diamond.unlocked },
                    unlock_platinum: { name: "Platinum Club", description: "Unlock Platinum.", category: "Progression", condition: () => this.state.resources.platinum.unlocked },
                    unlock_emerald: { name: "Emerald Expert", description: "Unlock Emeralds.", category: "Progression", condition: () => this.state.resources.emerald.unlocked },
                    unlock_ruby: { name: "Ruby Royalty", description: "Unlock Rubies.", category: "Progression", condition: () => this.state.resources.ruby.unlocked },
                    unlock_sapphire: { name: "Sapphire Sovereign", description: "Unlock Sapphires.", category: "Progression", condition: () => this.state.resources.sapphire.unlocked },
                    unlock_amethyst: { name: "Amethyst Aristocrat", description: "Unlock Amethysts.", category: "Progression", condition: () => this.state.resources.amethyst.unlocked },
                    unlock_obsidian: { name: "Master of Mines", description: "Unlock Obsidian.", category: "Progression", condition: () => this.state.resources.obsidian.unlocked },
                    unlock_mythril: { name: "Mythical Miner", description: "Unlock Mythril.", category: "Progression", condition: () => this.state.resources.mythril?.unlocked },
                    unlock_orichalcum: { name: "Legendary Extractor", description: "Unlock Orichalcum.", category: "Progression", condition: () => this.state.resources.orichalcum?.unlocked },
                    unlock_element_x: { name: "Forbidden Knowledge", description: "Unlock Element X.", category: "Progression", condition: () => this.state.resources.element_x?.unlocked },
                    first_prestige: { name: "New Beginning", description: "Perform your first Prestige.", category: "Progression", condition: () => this.state.prestige?.prestigesDone >= 1 },
                    
                    // Upgrade Milestones
                    first_upgrade_any: { name: "Tinkerer", description: "Buy any upgrade for any resource.", category: "Upgrades", condition: () => Object.values(this.state.resources).some(r => r.manualMineLevel > 0 || r.miners > 0 || r.minerSpeedLevel > 0) },
                    global_power_5: { name: "Global Power", description: "Reach Level 5 in any Global Upgrade.", category: "Upgrades", condition: () => Object.values(this.state.globalUpgrades).some(upg => upg.level >= 5) },
                    hundred_miners_stone: { name: "Stone Automation", description: "Own 100 Stone Miners.", category: "Upgrades", condition: () => this.state.resources.stone.miners >= 100 },
                    all_global_lvl_1: { name: "Well Rounded", description: "Upgrade all Global Upgrades to at least Level 1.", category: "Upgrades", condition: () => Object.values(this.state.globalUpgrades).every(upg => upg.level >= 1)},
                    
                    // Investment Achievements
                    first_investment: { name: "Market Dabbler", description: "Make your first investment.", category: "Investments", condition: () => Object.values(this.state.investments.portfolio).some(asset => asset.shares > 0) },
                    investment_profit_1k: { name: "Smart Investor", description: "Make $1,000 profit from investments.", category: "Investments", condition: () => (this.state.investments.totalSoldValue - this.state.investments.totalBoughtValue) >= 1000 },

                    // Processing Achievements
                    process_first_ingot: { name: "First Ingot", description: "Process your first Iron Ingot.", category: "Processing", condition: () => this.state.resources.iron_ingot?.count >= 1 && this.state.resources.iron_ingot?.unlocked, outputResourceId: 'iron_ingot' },
                    process_100_ingots: { name: "Skilled Smelter", description: "Process 100 Iron Ingots.", category: "Processing", condition: () => this.state.resources.iron_ingot?.count >= 100, outputResourceId: 'iron_ingot' },
                    process_first_copper_ingot: { name: "Copper Chaser", description: "Process your first Copper Ingot.", category: "Processing", condition: () => this.state.resources.copper_ingot?.count >= 1 && this.state.resources.copper_ingot?.unlocked, outputResourceId: 'copper_ingot' },
                    process_first_gold_bar: { name: "Gold Standard", description: "Process your first Gold Bar.", category: "Processing", condition: () => this.state.resources.gold_bar?.count >= 1 && this.state.resources.gold_bar?.unlocked, outputResourceId: 'gold_bar' },
                    process_first_silicon: { name: "Silicon Valley Start", description: "Process your first Silicon Wafer.", category: "Processing", condition: () => this.state.resources.silicon?.count >= 1 && this.state.resources.silicon?.unlocked, outputResourceId: 'silicon' },
                    process_first_steel: { name: "Steel Foundation", description: "Process your first Steel Plate.", category: "Processing", condition: () => this.state.resources.steel_plate?.count >= 1 && this.state.resources.steel_plate?.unlocked, outputResourceId: 'steel_plate' },
                    process_first_circuit: { name: "Circuit Board Genius", description: "Process your first Advanced Circuit.", category: "Processing", condition: () => this.state.resources.advanced_circuit?.count >= 1 && this.state.resources.advanced_circuit?.unlocked, outputResourceId: 'advanced_circuit' },
                    process_refined_x: { name: "Exotic Refinement", description: "Process your first Refined Element X.", category: "Processing", condition: () => this.state.resources.refined_element_x?.count >= 1 && this.state.resources.refined_element_x?.unlocked, outputResourceId: 'refined_element_x' },
                    process_quantum_entangler: { name: "Quantum Leap", description: "Create a Quantum Entangler.", category: "Processing", condition: () => this.state.resources.quantum_entangler?.count >= 1 && this.state.resources.quantum_entangler?.unlocked, outputResourceId: 'quantum_entangler' },
                    process_singularity_core: { name: "Heart of the Singularity", description: "Forge a Singularity Core.", category: "Processing", condition: () => this.state.resources.singularity_core?.count >= 1 && this.state.resources.singularity_core?.unlocked, outputResourceId: 'singularity_core' },
                    
                    first_polish: { name: "First Polish", description: "Polish your first gem.", category: "Processing", condition: () => Object.keys(this.state.processors).some(procId => procId.includes('_polisher') && this.state.resources[this.state.processors[procId].outputResourceId]?.count >= 1) },
                    polish_10_diamond: { name: "Diamond Cutter", description: "Produce 10 Polished Diamonds.", category: "Processing", condition: () => this.state.resources.polished_diamond?.count >= 10, outputResourceId: 'polished_diamond' },
                    polish_10_platinum: { name: "Platinum Shine", description: "Produce 10 Polished Platinum.", category: "Processing", condition: () => this.state.resources.polished_platinum?.count >= 10, outputResourceId: 'polished_platinum' },
                    polish_10_emerald: { name: "Emerald Gleam", description: "Produce 10 Polished Emeralds.", category: "Processing", condition: () => this.state.resources.polished_emerald?.count >= 10, outputResourceId: 'polished_emerald' },
                    polish_10_ruby: { name: "Ruby Radiance", description: "Produce 10 Polished Rubies.", category: "Processing", condition: () => this.state.resources.polished_ruby?.count >= 10, outputResourceId: 'polished_ruby' },
                    polish_10_sapphire: { name: "Sapphire Sparkle", description: "Produce 10 Polished Sapphires.", category: "Processing", condition: () => this.state.resources.polished_sapphire?.count >= 10, outputResourceId: 'polished_sapphire' },
                    polish_10_amethyst: { name: "Amethyst Aura", description: "Produce 10 Polished Amethysts.", category: "Processing", condition: () => this.state.resources.polished_amethyst?.count >= 10, outputResourceId: 'polished_amethyst' },
                    
                    unlock_all_processors: { name: "Industrial Revolution", description: "Unlock all available processors (excluding gem polishers & exotic).", category: "Processing", condition: () => Object.values(this.state.processors || {}).filter(p => !p.id.includes('_polisher') && !p.id.includes('_x_') && !p.id.includes('quantum_') && !p.id.includes('singularity_')).every(p => p.unlocked) },
                    unlock_all_exotic_processors: { name: "Master of Exotics", description: "Unlock all Exotic Material processors.", category: "Processing", condition: () => Object.values(this.state.processors || {}).filter(p => p.id.includes('_x_') || p.id.includes('quantum_') || p.id.includes('singularity_')).every(p => p.unlocked) },
                    master_jeweler: { name: "Master Jeweler", description: "Unlock all gem polishers.", category: "Processing", condition: () => Object.values(this.state.processors || {}).filter(p => p.id.includes('_polisher')).every(p => p.unlocked) },
                    master_processor: { name: "Master Processor", description: "Upgrade any non-gem/exotic processor to Level 5 in either Speed or Efficiency.", category: "Processing", condition: () => Object.values(this.state.processors || {}).filter(p => !p.id.includes('_polisher') && !p.id.includes('_x_') && !p.id.includes('quantum_') && !p.id.includes('singularity_')).some(p => p.speedLevel >= 5 || p.efficiencyLevel >= 5) },
                    gem_polishing_expert: { name: "Gem Polishing Expert", description: "Upgrade any gem polisher to Level 5 in either Speed or Efficiency.", category: "Processing", condition: () => Object.values(this.state.processors || {}).filter(p => p.id.includes('_polisher')).some(p => p.speedLevel >= 5 || p.efficiencyLevel >= 5) },

                    // Market Achievements
                    market_tycoon: { name: "Market Tycoon", description: "Sell $1,000,000 worth of goods via the individual market.", category: "Market", condition: () => this.state.stats.totalSoldViaMarketValue >= 1000000 },
                    strategic_seller: { name: "Strategic Seller", description: "Make 100 individual sales on the market.", category: "Market", condition: () => this.state.stats.individualMarketSalesCount >= 100 },
                    
                    // Research Achievements
                    first_research: { name: "Budding Scientist", description: "Complete your first research project.", category: "Research", condition: () => Object.values(this.state.research || {}).some(r => r.unlocked) },
                    all_research_complete: { name: "Master Researcher", description: "Complete all research projects.", category: "Research", condition: () => Object.values(this.state.research || {}).every(r => r.unlocked) },
                };
            },

            getInvestableAssetsDefinition() {
                return {
                    gold_futures: { name: "Gold Futures", basePrice: 70, volatility: 0.15, trend: 0.005 }, 
                    diamond_futures: { name: "Diamond Futures", basePrice: 240, volatility: 0.25, trend: 0.002 },
                    obsidian_futures: { name: "Obsidian Futures", basePrice: 700, volatility: 0.35, trend: -0.001 } 
                };
            },

            getPrestigeUpgradeDefinitions() {
                return {
                    heavenlyBonus: { level: 0, costBase: 1, costMultiplier: 1.5, effectPerLevel: 0.1, name: "Heavenly Bonus", description: "Increases all income permanently by 10% per level." },
                    timeWarp: { level: 0, costBase: 2, costMultiplier: 1.6, effectPerLevel: 0.05, name: "Time Warp", description: "Increases all miner and processor speeds permanently by 5% per level." },
                    researchGrant: { level: 0, costBase: 3, costMultiplier: 1.7, effectPerLevel: 0.03, name: "Research Grant", description: "Reduces all research times permanently by 3% per level (max 60%)." },
                    startingMiners: { level: 0, costBase: 1, costMultiplier: 2, effectPerLevel: 5, name: "Starting Crew", description: "Start each prestige with 5 extra Stone miners per level." }
                };
            },

            // --- Game State Management ---
            getDefaultState() {
                const baseState = { 
                    money: 0,
                    resources: { 
                        stone: { id: 'stone', name: 'Stone', count: 0, value: 1, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 10, miners: 0, minerCostBase: 25, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 20, unlocked: true, unlockRequirements: null },
                        coal: { id: 'coal', name: 'Coal', count: 0, value: 3, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 50, miners: 0, minerCostBase: 150, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 100, unlocked: false, unlockRequirements: { money: 100 } },
                        iron: { id: 'iron', name: 'Iron', count: 0, value: 10, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 200, miners: 0, minerCostBase: 750, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 500, unlocked: false, unlockRequirements: { money: 1000, resources: { coal: 50 } } },
                        copper: { id: 'copper', name: 'Copper', count: 0, value: 25, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 500, miners: 0, minerCostBase: 2000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 1200, unlocked: false, unlockRequirements: { money: 5000, resources: { iron: 20 } } },
                        quartz: { id: 'quartz', name: 'Quartz', count: 0, value: 15, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 300, miners: 0, minerCostBase: 1000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 800, unlocked: false, unlockRequirements: { money: 2500, resources: { stone: 500 }}},
                        gold: { id: 'gold', name: 'Gold', count: 0, value: 75, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 1500, miners: 0, minerCostBase: 8000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 4000, unlocked: false, unlockRequirements: { money: 25000, resources: { copper: 100 } } },
                        diamond: { id: 'diamond', name: 'Diamond', count: 0, value: 250, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 10000, miners: 0, minerCostBase: 50000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 20000, unlocked: false, unlockRequirements: { money: 100000, resources: { gold: 50 } } },
                        platinum: { id: 'platinum', name: 'Platinum', count: 0, value: 750, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 50000, miners: 0, minerCostBase: 250000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 100000, unlocked: false, unlockRequirements: { money: 500000, resources: { diamond: 100 } } },
                        emerald: { id: 'emerald', name: 'Emerald', count: 0, value: 2000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 200000, miners: 0, minerCostBase: 1000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 400000, unlocked: false, unlockRequirements: { money: 2500000, resources: { platinum: 75 } } },
                        ruby: { id: 'ruby', name: 'Ruby', count: 0, value: 5000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 800000, miners: 0, minerCostBase: 4000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 1500000, unlocked: false, unlockRequirements: { money: 10000000, resources: { emerald: 50 } } },
                        sapphire: { id: 'sapphire', name: 'Sapphire', count: 0, value: 12000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 3000000, miners: 0, minerCostBase: 15000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 6000000, unlocked: false, unlockRequirements: { money: 50000000, resources: { ruby: 40 } } },
                        amethyst: { id: 'amethyst', name: 'Amethyst', count: 0, value: 30000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 10000000, miners: 0, minerCostBase: 50000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 20000000, unlocked: false, unlockRequirements: { money: 200000000, resources: { sapphire: 30 } } },
                        obsidian: { id: 'obsidian', name: 'Obsidian', count: 0, value: 75000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 50000000, miners: 0, minerCostBase: 200000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 80000000, unlocked: false, unlockRequirements: { money: 1000000000, resources: { amethyst: 20 } } },
                        mythril: { id: 'mythril', name: 'Mythril', count: 0, value: 200000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 250000000, miners: 0, minerCostBase: 1000000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 400000000, unlocked: false, unlockRequirements: { money: 5000000000, resources: { obsidian: 100 } } },
                        orichalcum: { id: 'orichalcum', name: 'Orichalcum', count: 0, value: 1000000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 1000000000, miners: 0, minerCostBase: 5000000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 2000000000, unlocked: false, unlockRequirements: { money: 25000000000, resources: { mythril: 50 } } },
                        element_x: { id: 'element_x', name: 'Element X', count: 0, value: 5000000, manualMineBaseAmount: 1, manualMineLevel: 0, manualMineUpgradeCostBase: 50000000000, miners: 0, minerCostBase: 200000000000, minerProductionBase: 0.2, minerSpeedLevel: 0, minerSpeedUpgradeCostBase: 100000000000, unlocked: false, unlockRequirements: null }, // Unlocked via research
                        // Processed Resources
                        iron_ingot: { id: 'iron_ingot', name: 'Iron Ingot', count: 0, value: 150, unlocked: false }, 
                        copper_ingot: { id: 'copper_ingot', name: 'Copper Ingot', count: 0, value: 300, unlocked: false },
                        gold_bar: { id: 'gold_bar', name: 'Gold Bar', count: 0, value: 600, unlocked: false },
                        silicon: { id: 'silicon', name: 'Silicon Wafer', count: 0, value: 250, unlocked: false},
                        steel_plate: { id: 'steel_plate', name: 'Steel Plate', count: 0, value: 1300, unlocked: false},
                        advanced_circuit: { id: 'advanced_circuit', name: 'Adv. Circuit', count: 0, value: 6000, unlocked: false},
                        // Polished Gems
                        polished_diamond: { id: 'polished_diamond', name: 'Polished Diamond', count: 0, value: 750, unlocked: false }, 
                        polished_platinum: { id: 'polished_platinum', name: 'Polished Platinum', count: 0, value: 2200, unlocked: false }, 
                        polished_emerald: { id: 'polished_emerald', name: 'Polished Emerald', count: 0, value: 5800, unlocked: false }, 
                        polished_ruby: { id: 'polished_ruby', name: 'Polished Ruby', count: 0, value: 14500, unlocked: false }, 
                        polished_sapphire: { id: 'polished_sapphire', name: 'Polished Sapphire', count: 0, value: 34000, unlocked: false }, 
                        polished_amethyst: { id: 'polished_amethyst', name: 'Polished Amethyst', count: 0, value: 85000, unlocked: false }, 
                        // Exotic Processed Materials
                        refined_element_x: { id: 'refined_element_x', name: 'Refined Element X', count: 0, value: 25000000, unlocked: false }, 
                        quantum_entangler: { id: 'quantum_entangler', name: 'Quantum Entangler', count: 0, value: 150000000, unlocked: false }, 
                        singularity_core: { id: 'singularity_core', name: 'Singularity Core', count: 0, value: 1000000000, unlocked: false }, 
                    },
                    globalUpgrades: {
                        sellMultiplier: { level: 0, costBase: 1000, value: 1, increasePerLevel: 0.05, name: "Global Sell Multiplier", description: "Increases the sell price of all resources."},
                        minerSpeedBoost: { level: 0, costBase: 2500, value: 1, increasePerLevel: 0.03, name: "Global Miner Speed Boost", description: "Boosts the speed of all automated miners."},
                        manualMiningBoost: { level: 0, costBase: 500, value: 1, increasePerLevel: 0.1, name: "Global Manual Mining Boost", description: "Increases resources gained per manual click for all types."},
                        researchAndDevelopment: { level: 0, costBase: 10000, value: 1, increasePerLevel: 0.02, name: "Research & Development", description: "Reduces the cost to unlock new resources (2% per level, max 50%)."}, 
                        efficiencyTraining: { level: 0, costBase: 7500, value: 1, increasePerLevel: 0.015, name: "Efficiency Training", description: "Reduces the cost of all resource-specific upgrades (1.5% per level, max 40%)."}, 
                        masterGeologist: { level: 0, costBase: 12000, value: 1, increasePerLevel: 0.05, name: "Master Geologist", description: "Further increases resources gained from manual clicks (stacks with other boosts)."} 
                    },
                    achievements: {}, 
                    investments: { 
                        market: {}, 
                        portfolio: {}, 
                        totalBoughtValue: 0, 
                        totalSoldValue: 0,   
                        transactionFee: 0.005 
                    },
                    processors: {
                        iron_smelter: {
                            id: 'iron_smelter', name: 'Iron Smelter', 
                            inputs: [{id: 'iron', amountBase: 10}],
                            outputResourceId: 'iron_ingot', outputAmountBase: 1, processingTimeBase: 10, 
                            costToProcessBase: 5, speedLevel: 0, efficiencyLevel: 0, 
                            speedUpgradeCostBase: 500, efficiencyUpgradeCostBase: 750,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { iron: 100 }, money: 200 }
                        },
                        copper_smelter: {
                            id: 'copper_smelter', name: 'Copper Smelter', 
                            inputs: [{id: 'copper', amountBase: 8}],
                            outputResourceId: 'copper_ingot', outputAmountBase: 1, processingTimeBase: 15,
                            costToProcessBase: 15, speedLevel: 0, efficiencyLevel: 0,
                            speedUpgradeCostBase: 1200, efficiencyUpgradeCostBase: 1800,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { copper: 100, coal: 50 }, money: 1000 }
                        },
                        gold_refinery: {
                            id: 'gold_refinery', name: 'Gold Refinery', 
                            inputs: [{id: 'gold', amountBase: 5}],
                            outputResourceId: 'gold_bar', outputAmountBase: 1, processingTimeBase: 25,
                            costToProcessBase: 50, speedLevel: 0, efficiencyLevel: 0,
                            speedUpgradeCostBase: 4000, efficiencyUpgradeCostBase: 6000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { gold: 50, iron_ingot: 10 }, money: 5000 }
                        },
                        quartz_purifier: {
                            id: 'quartz_purifier', name: 'Quartz Purifier',
                            inputs: [{id: 'quartz', amountBase: 10}],
                            outputResourceId: 'silicon', outputAmountBase: 1, processingTimeBase: 12,
                            costToProcessBase: 20, speedLevel: 0, efficiencyLevel: 0,
                            speedUpgradeCostBase: 1500, efficiencyUpgradeCostBase: 2200,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { quartz: 100, coal: 200 }, money: 3000 }
                        },
                        steel_mill: {
                            id: 'steel_mill', name: 'Steel Mill',
                            inputs: [{id: 'iron_ingot', amountBase: 5}, {id: 'coal', amountBase: 10}],
                            outputResourceId: 'steel_plate', outputAmountBase: 1, processingTimeBase: 30,
                            costToProcessBase: 100, speedLevel: 0, efficiencyLevel: 0,
                            speedUpgradeCostBase: 8000, efficiencyUpgradeCostBase: 10000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { iron_ingot: 50, coal: 500 }, money: 15000 }
                        },
                        electronics_assembler: {
                            id: 'electronics_assembler', name: 'Electronics Assembler',
                            inputs: [{id: 'gold_bar', amountBase: 2}, {id: 'copper_ingot', amountBase: 5}, {id: 'silicon', amountBase: 3}],
                            outputResourceId: 'advanced_circuit', outputAmountBase: 1, processingTimeBase: 60,
                            costToProcessBase: 500, speedLevel: 0, efficiencyLevel: 0,
                            speedUpgradeCostBase: 25000, efficiencyUpgradeCostBase: 35000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { gold_bar: 20, copper_ingot: 50, silicon: 30 }, money: 100000 }
                        },
                        // Gem Polishers
                        diamond_polisher: {
                            id: 'diamond_polisher', name: 'Diamond Polisher', inputs: [{id: 'diamond', amountBase: 1}],
                            outputResourceId: 'polished_diamond', outputAmountBase: 1, processingTimeBase: 45, costToProcessBase: 125, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 100000, efficiencyUpgradeCostBase: 150000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { diamond: 20, steel_plate: 10 }, money: 200000 }
                        },
                        platinum_polisher: {
                            id: 'platinum_polisher', name: 'Platinum Polisher', inputs: [{id: 'platinum', amountBase: 1}],
                            outputResourceId: 'polished_platinum', outputAmountBase: 1, processingTimeBase: 50, costToProcessBase: 375, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 250000, efficiencyUpgradeCostBase: 350000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { platinum: 20, advanced_circuit: 5 }, money: 500000 }
                        },
                        emerald_polisher: {
                            id: 'emerald_polisher', name: 'Emerald Polisher', inputs: [{id: 'emerald', amountBase: 1}],
                            outputResourceId: 'polished_emerald', outputAmountBase: 1, processingTimeBase: 55, costToProcessBase: 1000, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 1000000, efficiencyUpgradeCostBase: 1500000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { emerald: 15, steel_plate: 20 }, money: 2000000 }
                        },
                         ruby_polisher: {
                            id: 'ruby_polisher', name: 'Ruby Polisher', inputs: [{id: 'ruby', amountBase: 1}],
                            outputResourceId: 'polished_ruby', outputAmountBase: 1, processingTimeBase: 60, costToProcessBase: 2500, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 4000000, efficiencyUpgradeCostBase: 6000000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { ruby: 15, advanced_circuit: 10 }, money: 8000000 }
                        },
                        sapphire_polisher: {
                            id: 'sapphire_polisher', name: 'Sapphire Polisher', inputs: [{id: 'sapphire', amountBase: 1}],
                            outputResourceId: 'polished_sapphire', outputAmountBase: 1, processingTimeBase: 65, costToProcessBase: 6000, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 15000000, efficiencyUpgradeCostBase: 20000000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { sapphire: 10, steel_plate: 30 }, money: 30000000 }
                        },
                        amethyst_polisher: {
                            id: 'amethyst_polisher', name: 'Amethyst Polisher', inputs: [{id: 'amethyst', amountBase: 1}],
                            outputResourceId: 'polished_amethyst', outputAmountBase: 1, processingTimeBase: 70, costToProcessBase: 15000, 
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 50000000, efficiencyUpgradeCostBase: 70000000,
                            isActive: false, currentProgress: 0, unlocked: false,
                            unlockRequirements: { resources: { amethyst: 10, advanced_circuit: 20 }, money: 100000000 }
                        },
                        // Exotic Processors - Unlocked via Research
                        element_x_refinery: {
                            id: 'element_x_refinery', name: 'Element X Refinery', inputs: [{id: 'element_x', amountBase: 1}, {id: 'orichalcum', amountBase: 5}, {id: 'mythril', amountBase: 10}],
                            outputResourceId: 'refined_element_x', outputAmountBase: 1, processingTimeBase: 120, costToProcessBase: 10000000,
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 500000000, efficiencyUpgradeCostBase: 750000000,
                            isActive: false, currentProgress: 0, unlocked: false, unlockRequirements: null 
                        },
                        quantum_assembler: {
                            id: 'quantum_assembler', name: 'Quantum Assembler', inputs: [{id: 'refined_element_x', amountBase: 1}, {id: 'advanced_circuit', amountBase: 10}, {id: 'polished_diamond', amountBase: 5}],
                            outputResourceId: 'quantum_entangler', outputAmountBase: 1, processingTimeBase: 300, costToProcessBase: 50000000,
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 2000000000, efficiencyUpgradeCostBase: 3000000000,
                            isActive: false, currentProgress: 0, unlocked: false, unlockRequirements: null
                        },
                        singularity_forge: {
                            id: 'singularity_forge', name: 'Singularity Forge', inputs: [{id: 'quantum_entangler', amountBase: 1}, {id: 'orichalcum', amountBase: 50}, {id: 'polished_amethyst', amountBase: 10}],
                            outputResourceId: 'singularity_core', outputAmountBase: 1, processingTimeBase: 600, costToProcessBase: 250000000,
                            speedLevel: 0, efficiencyLevel: 0, speedUpgradeCostBase: 10000000000, efficiencyUpgradeCostBase: 15000000000,
                            isActive: false, currentProgress: 0, unlocked: false, unlockRequirements: null
                        }
                    },
                    research: { 
                        unlock_deep_core_drill: { id: 'unlock_deep_core_drill', name: 'Deep Core Drilling Tech', description: 'Unlocks the Deep Core Drill to mine Element X.', cost: { money: 10000000000, resources: { orichalcum: 100, mythril: 200, advanced_circuit: 50 } }, researchTimeBase: 300, isResearching: false, currentProgress: 0, unlocked: false, unlocksResource: 'element_x' },
                        unlock_element_x_refinery: { id: 'unlock_element_x_refinery', name: 'Element X Refining', description: 'Unlocks the Element X Refinery.', cost: { money: 50000000000, resources: { element_x: 5 } }, researchTimeBase: 180, isResearching: false, currentProgress: 0, unlocked: false, unlocksProcessor: 'element_x_refinery', requiresResearch: 'unlock_deep_core_drill' },
                        unlock_quantum_assembler: { id: 'unlock_quantum_assembler', name: 'Quantum Entanglement', description: 'Unlocks the Quantum Assembler.', cost: { money: 250000000000, resources: { refined_element_x: 5, advanced_circuit: 100 } }, researchTimeBase: 450, isResearching: false, currentProgress: 0, unlocked: false, unlocksProcessor: 'quantum_assembler', requiresResearch: 'unlock_element_x_refinery' },
                        unlock_singularity_forge: { id: 'unlock_singularity_forge', name: 'Singularity Forging', description: 'Unlocks the Singularity Forge.', cost: { money: 1000000000000, resources: { quantum_entangler: 5, orichalcum: 250 } }, researchTimeBase: 900, isResearching: false, currentProgress: 0, unlocked: false, unlocksProcessor: 'singularity_forge', requiresResearch: 'unlock_quantum_assembler' }
                    },
                    prestige: { // New prestige state
                        points: 0,
                        totalPointsEverEarned: 0,
                        prestigesDone: 0,
                        upgrades: JSON.parse(JSON.stringify(this.getPrestigeUpgradeDefinitions())), // Deep copy
                        lastPrestigeAt: null,
                        minMoneyForPrestige: 1e12 // Minimum total money ever earned to allow first prestige
                    },
                    stats: { 
                        totalSoldViaMarketValue: 0,
                        individualMarketSalesCount: 0,
                        totalMoneyFromPreviousPrestiges: 0, // Tracks money for prestige point calculation
                    },
                    lastUpdate: Date.now(),
                    lastSave: null,
                    currentTab: 'mines', 
                };
                Object.keys(this.achievementsList).forEach(achId => {
                    baseState.achievements[achId] = { unlocked: false, unlockedAt: null };
                });
                Object.keys(this.investableAssets).forEach(assetId => {
                    baseState.investments.market[assetId] = { 
                        currentPrice: this.investableAssets[assetId].basePrice, 
                        lastPrice: this.investableAssets[assetId].basePrice,
                        trendArrow: '&#8212;' 
                    };
                    baseState.investments.portfolio[assetId] = { shares: 0, avgBuyPrice: 0 };
                });
                return JSON.parse(JSON.stringify(baseState)); 
            },
            
            resetState(isPrestigeReset = false) {
                const achievementsToKeep = isPrestigeReset ? JSON.parse(JSON.stringify(this.state.achievements)) : {};
                const statsToKeep = isPrestigeReset ? {
                    totalSoldViaMarketValue: this.state.stats.totalSoldViaMarketValue,
                    individualMarketSalesCount: this.state.stats.individualMarketSalesCount,
                    totalMoneyFromPreviousPrestiges: this.state.stats.totalMoneyFromPreviousPrestiges + this.state.money, // Add current run's money
                } : { totalSoldViaMarketValue: 0, individualMarketSalesCount: 0, totalMoneyFromPreviousPrestiges: 0 };

                let prestigeDataToKeep;
                if (isPrestigeReset) {
                    prestigeDataToKeep = JSON.parse(JSON.stringify(this.state.prestige));
                    const ppGained = this.calculatePrestigePointsToGain();
                    prestigeDataToKeep.points += ppGained;
                    prestigeDataToKeep.totalPointsEverEarned += ppGained;
                    prestigeDataToKeep.prestigesDone++;
                    prestigeDataToKeep.lastPrestigeAt = Date.now();
                } else {
                    prestigeDataToKeep = JSON.parse(JSON.stringify(this.getPrestigeUpgradeDefinitions())); // Get fresh definitions
                     prestigeDataToKeep = { // Full reset for prestige object
                        points: 0,
                        totalPointsEverEarned: 0,
                        prestigesDone: 0,
                        upgrades: JSON.parse(JSON.stringify(this.getPrestigeUpgradeDefinitions())),
                        lastPrestigeAt: null,
                        minMoneyForPrestige: 1e12
                    };
                }
                
                this.state = this.getDefaultState(); // Get a fresh default state

                // Restore preserved data
                this.state.achievements = achievementsToKeep;
                Object.keys(this.achievementsList).forEach(achId => { // Ensure all achievement slots exist
                    if (!this.state.achievements[achId]) {
                        this.state.achievements[achId] = { unlocked: false, unlockedAt: null };
                    }
                });

                this.state.stats = { ...this.state.stats, ...statsToKeep };
                this.state.prestige = prestigeDataToKeep;

                if (isPrestigeReset) {
                    // Apply starting miners from prestige upgrade
                    const startingMinerBonus = this.state.prestige.upgrades.startingMiners.level * this.state.prestige.upgrades.startingMiners.effectPerLevel;
                    if (this.state.resources.stone) {
                        this.state.resources.stone.miners += startingMinerBonus;
                    }
                }

                this.state.lastUpdate = Date.now();
                console.log(isPrestigeReset ? "Game state reset for Prestige." : "Game state hard reset to default.");

                if (db && userId && isAuthReady) {
                    this.saveGame(true); 
                }
                this.render(); 
            },

            calculateOfflineProgression(lastKnownUpdateTime) {
                if (!this.state || !this.state.resources || !lastKnownUpdateTime) return;

                const now = Date.now();
                const offlineTimeSeconds = Math.max(0, (now - lastKnownUpdateTime) / 1000);

                if (offlineTimeSeconds < 10) { 
                    this.state.lastUpdate = now;
                    return;
                }

                let offlineSummary = "Welcome back! While you were away:<br>"; 
                let anyProduction = false;

                // Miner production
                for (const resKey in this.state.resources) {
                    const resource = this.state.resources[resKey];
                    if (resource.unlocked && resource.miners > 0 && resource.minerProductionBase) {
                        const productionPerSecond = resource.miners * this.getMinerProduction(resource);
                        const offlineGain = productionPerSecond * offlineTimeSeconds;
                        if (offlineGain > 0) {
                            resource.count += offlineGain;
                            offlineSummary += `+ ${this.formatNumber(offlineGain)} ${resource.name} (mined)<br>`;
                            anyProduction = true;
                        }
                    }
                }

                // Processor production
                for (const procId in this.state.processors) {
                    const processor = this.state.processors[procId];
                    if (processor.unlocked && processor.isActive) { 
                        const actualProcessingTime = this.getActualProcessingTime(processor);
                        const batchesPossible = Math.floor(offlineTimeSeconds / actualProcessingTime);
                        const actualInputAmounts = this.getActualInputAmounts(processor); 
                        const actualOutputAmount = processor.outputAmountBase;

                        let batchesCompleted = 0;
                        for (let i = 0; i < batchesPossible; i++) {
                            let canProcessBatch = true;
                            for (const input of actualInputAmounts) {
                                if (this.state.resources[input.id].count < input.amount) {
                                    canProcessBatch = false;
                                    break;
                                }
                            }

                            if (canProcessBatch) {
                                for (const input of actualInputAmounts) {
                                    this.state.resources[input.id].count -= input.amount;
                                }
                                this.state.resources[processor.outputResourceId].count += actualOutputAmount;
                                if (!this.state.resources[processor.outputResourceId].unlocked) {
                                    this.state.resources[processor.outputResourceId].unlocked = true;
                                }
                                batchesCompleted++;
                            } else {
                                break; 
                            }
                        }
                        if (batchesCompleted > 0) {
                             offlineSummary += `+ ${this.formatNumber(batchesCompleted * actualOutputAmount)} ${this.state.resources[processor.outputResourceId].name} (processed)<br>`;
                             anyProduction = true;
                        }
                        // Decide if processor should remain active or reset based on game design
                        // For simplicity, let's assume it completes what it can and stops.
                        processor.isActive = false; 
                        processor.currentProgress = 0;
                    }
                }

                // Offline Research
                for (const researchId in this.state.research) {
                    const researchItem = this.state.research[researchId];
                    if (researchItem.isResearching && !researchItem.unlocked) {
                        const actualResearchTime = this.getActualResearchTime(researchItem);
                        const remainingTime = actualResearchTime - researchItem.currentProgress;
                        const offlineResearchProgress = Math.min(remainingTime, offlineTimeSeconds);
                        researchItem.currentProgress += offlineResearchProgress;
                        
                        if (researchItem.currentProgress >= actualResearchTime) {
                            researchItem.unlocked = true;
                            researchItem.isResearching = false;
                            researchItem.currentProgress = actualResearchTime; // Cap progress
                            offlineSummary += `Research: ${researchItem.name} completed!<br>`;
                            anyProduction = true; // To show the toast
                            this.handleResearchCompletion(researchId);
                        } else {
                             offlineSummary += `Research: ${researchItem.name} progressed by ${this.formatNumber(offlineResearchProgress)}s.<br>`;
                             anyProduction = true;
                        }
                    }
                }
                
                this.state.lastUpdate = now; 

                if (anyProduction) {
                    this.showToast(offlineSummary, false, 10000); 
                    console.log("Offline progression calculated:", offlineSummary.replace(/<br>/g, '\n'));
                } else {
                    console.log("No significant offline progression to calculate.");
                }
            },


            async loadGame() { // Loads from Firestore
                if (!db || !userId) {
                    this.resetState(false); 
                    this.calculateOfflineProgression(Date.now());
                    this.render();
                    const lm = document.getElementById('loading-message'); if (lm) lm.classList.add('hidden');
                    return;
                }
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/mineTycoon/gameState`);
                if (gameSaveUnsubscribe) gameSaveUnsubscribe(); 
                
                try {
                    gameSaveUnsubscribe = onSnapshot(docRef, async (docSnap) => {
                        const defaultState = this.getDefaultState(); 
                        let lastKnownUpdateTime = Date.now(); 

                        if (docSnap.exists()) {
                            const loadedData = docSnap.data();
                            this.applyLoadedState(loadedData, defaultState); // Use helper to apply state
                            lastKnownUpdateTime = loadedData.lastUpdate || defaultState.lastUpdate; 
                            console.log("Game loaded and merged from Firestore:", JSON.parse(JSON.stringify(this.state)));
                        } else {
                            console.log("No saved game found. Starting new game.");
                            this.resetState(false); // Non-prestige reset
                            await this.saveGame(true); 
                            lastKnownUpdateTime = this.state.lastUpdate; 
                        }
                        
                        this.calculateOfflineProgression(lastKnownUpdateTime);
                        
                        this.checkAllAchievements(false); 
                        this.render();
                        const lm = document.getElementById('loading-message'); if (lm) lm.classList.add('hidden');
                    }, (error) => {
                        console.error("Error listening to game state:", error);
                        this.resetState(false); 
                        this.calculateOfflineProgression(Date.now()); 
                        this.render();
                        const lm = document.getElementById('loading-message'); if (lm) lm.classList.add('hidden');
                    });
                } catch (error) {
                    console.error("Error setting up onSnapshot listener:", error);
                    this.resetState(false); 
                    this.calculateOfflineProgression(Date.now()); 
                    this.render();
                    const lm = document.getElementById('loading-message'); if (lm) lm.classList.add('hidden');
                }
            },

            applyLoadedState(loadedData, defaultState) {
                this.state = { ...defaultState }; // Start with a fresh default state structure

                // Merge top-level primitive properties
                for (const key in defaultState) {
                    if (loadedData.hasOwnProperty(key) && typeof loadedData[key] !== 'object' && 
                        key !== 'achievements' && key !== 'investments' && 
                        key !== 'resources' && key !== 'globalUpgrades' &&
                        key !== 'processors' && key !== 'research' && 
                        key !== 'stats' && key !== 'prestige' ) { 
                        this.state[key] = loadedData[key];
                    }
                }
                this.state.money = loadedData.money !== undefined ? loadedData.money : defaultState.money;

                // Merge nested objects carefully, ensuring all default keys exist
                this.state.resources = {}; 
                for (const resKey in defaultState.resources) {
                    this.state.resources[resKey] = { 
                        ...defaultState.resources[resKey], 
                        ...(loadedData.resources ? loadedData.resources[resKey] : {}) 
                    };
                }
                
                this.state.globalUpgrades = {};
                for (const upgKey in defaultState.globalUpgrades) {
                    this.state.globalUpgrades[upgKey] = { 
                        ...defaultState.globalUpgrades[upgKey], 
                        ...(loadedData.globalUpgrades ? loadedData.globalUpgrades[upgKey] : {}) 
                    };
                }
                
                this.state.achievements = {}; 
                Object.keys(this.achievementsList).forEach(achId => { 
                    this.state.achievements[achId] = { 
                        ...(defaultState.achievements[achId] || { unlocked: false, unlockedAt: null }), 
                        ...(loadedData.achievements ? loadedData.achievements[achId] : {}) 
                    };
                });

                this.state.investments = { ...defaultState.investments }; 
                if (loadedData.investments) {
                    this.state.investments.totalBoughtValue = loadedData.investments.totalBoughtValue || 0;
                    this.state.investments.totalSoldValue = loadedData.investments.totalSoldValue || 0;
                    this.state.investments.transactionFee = loadedData.investments.transactionFee || defaultState.investments.transactionFee;
                    
                    Object.keys(this.investableAssets).forEach(assetId => {
                        this.state.investments.market[assetId] = { 
                            ...(defaultState.investments.market[assetId] || {}), 
                            ...(loadedData.investments.market ? loadedData.investments.market[assetId] : {}) 
                        };
                        this.state.investments.portfolio[assetId] = { 
                            ...(defaultState.investments.portfolio[assetId] || { shares: 0, avgBuyPrice: 0 }), 
                            ...(loadedData.investments.portfolio ? loadedData.investments.portfolio[assetId] : {}) 
                        };
                    });
                }
                this.state.processors = {};
                for (const procKey in defaultState.processors) {
                    this.state.processors[procKey] = {
                        ...defaultState.processors[procKey],
                        ...(loadedData.processors ? loadedData.processors[procKey] : {})
                    };
                    this.state.processors[procKey].isActive = this.state.processors[procKey].isActive || false;
                    this.state.processors[procKey].currentProgress = this.state.processors[procKey].currentProgress || 0;
                }
                this.state.research = {};
                for (const researchKey in defaultState.research) {
                    this.state.research[researchKey] = {
                        ...defaultState.research[researchKey],
                        ...(loadedData.research ? loadedData.research[researchKey] : {})
                    };
                    this.state.research[researchKey].isResearching = this.state.research[researchKey].isResearching || false;
                    this.state.research[researchKey].currentProgress = this.state.research[researchKey].currentProgress || 0;
                }
                this.state.stats = { ...defaultState.stats, ...(loadedData.stats || {}) };

                this.state.prestige = { ...defaultState.prestige };
                if (loadedData.prestige) {
                    this.state.prestige.points = loadedData.prestige.points || 0;
                    this.state.prestige.totalPointsEverEarned = loadedData.prestige.totalPointsEverEarned || 0;
                    this.state.prestige.prestigesDone = loadedData.prestige.prestigesDone || 0;
                    this.state.prestige.lastPrestigeAt = loadedData.prestige.lastPrestigeAt || null;
                    this.state.prestige.minMoneyForPrestige = loadedData.prestige.minMoneyForPrestige || defaultState.prestige.minMoneyForPrestige;
                    this.state.prestige.upgrades = {};
                    for (const pUpgKey in defaultState.prestige.upgrades) { // Use prestigeUpgradeDefinitions for structure
                        this.state.prestige.upgrades[pUpgKey] = {
                            ...defaultState.prestige.upgrades[pUpgKey],
                            ...(loadedData.prestige.upgrades ? loadedData.prestige.upgrades[pUpgKey] : {})
                        };
                    }
                }
                this.state.lastUpdate = loadedData.lastUpdate || defaultState.lastUpdate;
                this.state.lastSave = loadedData.lastSave || null;
                this.state.currentTab = loadedData.currentTab || defaultState.currentTab;
            },


            async saveGame(showToastOnSuccess = false) { 
                if (!db || !userId || !isAuthReady) {
                    console.log("Save conditions not met (no DB or user, or auth not ready). Skipping save.");
                    return;
                }
                this.state.lastUpdate = Date.now(); 
                this.state.lastSave = Date.now(); 
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/mineTycoon/gameState`);
                    const stateToSave = JSON.parse(JSON.stringify(this.state)); // Deep copy for saving
                    await setDoc(docRef, stateToSave, { merge: true }); 
                    console.log("Game saved to Firestore.");
                    if(showToastOnSuccess) this.showToast("Game Saved!"); 
                } catch (error) {
                    console.error("Error saving game:", error);
                    if(showToastOnSuccess) this.showToast("Error saving game!", true);
                }
            },
            
            autoSaveGame() {
                if (userId && isAuthReady) { 
                    this.saveGame(false); 
                }
            },

            startMarketUpdates() {
                if (marketUpdateInterval) clearInterval(marketUpdateInterval);
                const updateFrequency = () => (Math.random() * 120 + 60) * 1000; 
                
                const updateMarket = () => {
                    if (!this.state || !this.state.investments) return; 
                    Object.keys(this.investableAssets).forEach(assetId => {
                        const assetDef = this.investableAssets[assetId];
                        const marketData = this.state.investments.market[assetId];
                        if (!marketData) return; 
                        
                        marketData.lastPrice = marketData.currentPrice;
                        
                        const randomChange = (Math.random() - 0.5) * 2 * assetDef.volatility; 
                        let newPrice = marketData.currentPrice * (1 + randomChange + assetDef.trend);
                        newPrice = Math.max(newPrice, assetDef.basePrice * 0.1); 
                        newPrice = Math.min(newPrice, assetDef.basePrice * 10); 
                        marketData.currentPrice = Math.round(newPrice * 100) / 100; 

                        if (marketData.currentPrice > marketData.lastPrice) marketData.trendArrow = '<span class="text-green-400">&#9650;</span>'; 
                        else if (marketData.currentPrice < marketData.lastPrice) marketData.trendArrow = '<span class="text-red-400">&#9660;</span>'; 
                        else marketData.trendArrow = '<span class="text-slate-400">&#8212;</span>'; 
                    });
                    if(this.state.currentTab === 'investments') this.render(); 
                    marketUpdateInterval = setTimeout(updateMarket, updateFrequency());
                };
                marketUpdateInterval = setTimeout(updateMarket, updateFrequency());
            },

            buyShares(assetId, amount) {
                amount = parseInt(amount);
                if (isNaN(amount) || amount <= 0) {
                    this.showToast("Invalid amount.", true);
                    return;
                }
                const marketData = this.state.investments.market[assetId];
                const portfolioData = this.state.investments.portfolio[assetId];
                if (!marketData || !portfolioData) { this.showToast("Asset data not found.", true); return; }

                const cost = marketData.currentPrice * amount;
                const fee = cost * this.state.investments.transactionFee;
                const totalCost = cost + fee;

                if (this.state.money >= totalCost) {
                    this.state.money -= totalCost;
                    
                    const newTotalShares = portfolioData.shares + amount;
                    const newTotalValue = (portfolioData.avgBuyPrice * portfolioData.shares) + cost; 
                    portfolioData.avgBuyPrice = newTotalShares > 0 ? newTotalValue / newTotalShares : 0;
                    portfolioData.shares += amount;

                    this.state.investments.totalBoughtValue += cost; 

                    this.showToast(`Bought ${amount} ${this.investableAssets[assetId].name} shares for $${this.formatNumber(totalCost, 2)} (incl. $${this.formatNumber(fee,2)} fee).`);
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money!", true);
                }
            },

            sellShares(assetId, amount) {
                amount = parseInt(amount);
                const portfolioData = this.state.investments.portfolio[assetId];
                if (!portfolioData) { this.showToast("Asset data not found.", true); return; }

                if (isNaN(amount) || amount <= 0 || amount > portfolioData.shares) {
                    this.showToast("Invalid amount or not enough shares.", true);
                    return;
                }
                const marketData = this.state.investments.market[assetId];
                if (!marketData) { this.showToast("Market data not found.", true); return; }

                const revenue = marketData.currentPrice * amount;
                const fee = revenue * this.state.investments.transactionFee;
                const totalRevenue = revenue - fee;

                this.state.money += totalRevenue;
                portfolioData.shares -= amount;
                if (portfolioData.shares === 0) {
                    portfolioData.avgBuyPrice = 0; 
                }
                this.state.investments.totalSoldValue += revenue; 

                this.showToast(`Sold ${amount} ${this.investableAssets[assetId].name} shares for $${this.formatNumber(totalRevenue, 2)} (after $${this.formatNumber(fee,2)} fee).`);
                this.checkAllAchievements();
                this.render();
                this.saveGame(true);
            },

            checkAllAchievements(showNotification = true) {
                if (!this.state || !this.state.achievements || !this.achievementsList) return;
                let newAchievementUnlocked = false;
                for (const achId in this.achievementsList) {
                    if (!this.achievementsList.hasOwnProperty(achId)) continue;
                    if (!this.state.achievements[achId]) { // Initialize if missing (e.g. new achievement added)
                         this.state.achievements[achId] = { unlocked: false, unlockedAt: null };
                    }

                    if (!this.state.achievements[achId].unlocked) { 
                        const achievement = this.achievementsList[achId];
                        try {
                            let conditionMet = false;
                            // Handle cases where resources/processors might not exist yet (e.g. early game or after reset)
                            if (achId.includes("process_") || achId.includes("processor") || achId.includes("polish_") || achId.includes("jeweler") || achId.includes("polishing_expert") || achId.includes("research")) {
                                const outputResId = achievement.outputResourceId; 
                                const requiredResearch = achievement.requiresResearch;
                                if (!this.state.processors || (outputResId && !this.state.resources[outputResId]) || (requiredResearch && (!this.state.research || !this.state.research[requiredResearch]?.unlocked))) {
                                    conditionMet = false;
                                } else {
                                     conditionMet = achievement.condition();
                                }
                            } else if ( (achId.startsWith("mine_mythril") && !this.state.resources.mythril) ||
                                (achId.startsWith("mine_orichalcum") && !this.state.resources.orichalcum) ||
                                (achId.startsWith("unlock_mythril") && !this.state.resources.mythril) ||
                                (achId.startsWith("unlock_orichalcum") && !this.state.resources.orichalcum) ||
                                (achId.startsWith("mine_quartz") && !this.state.resources.quartz) ||
                                (achId.startsWith("unlock_quartz") && !this.state.resources.quartz) ||
                                (achId.startsWith("mine_element_x") && !this.state.resources.element_x) ||
                                (achId.startsWith("unlock_element_x") && !this.state.resources.element_x) ||
                                (achId === "first_prestige" && !this.state.prestige) // Check if prestige object exists
                                ) {
                                conditionMet = false;
                            } else {
                                conditionMet = achievement.condition();
                            }
                            
                            if (conditionMet) {
                                this.state.achievements[achId].unlocked = true;
                                this.state.achievements[achId].unlockedAt = Date.now();
                                if (showNotification) {
                                    this.showToast(`Achievement Unlocked: ${achievement.name}!`, false);
                                }
                                newAchievementUnlocked = true;
                                console.log(`Achievement unlocked: ${achievement.name}`);
                            }
                        } catch (e) {
                            console.error(`Error checking achievement ${achId}:`, e, "State:", JSON.parse(JSON.stringify(this.state)));
                        }
                    }
                }
                if (newAchievementUnlocked) {
                    this.render(); 
                    this.saveGame(false); 
                }
            },

            update() { 
                if (!isAuthReady || !this.state || !this.state.resources) return; 

                const now = Date.now();
                const deltaTime = (now - (this.state.lastUpdate || now)) / 1000; 

                for (const resKey in this.state.resources) {
                    const resource = this.state.resources[resKey];
                    if (resource.unlocked && resource.miners > 0 && resource.minerProductionBase) { 
                        const productionPerSecond = resource.miners * this.getMinerProduction(resource);
                        resource.count += productionPerSecond * deltaTime;
                    }
                }

                if (this.state.processors) {
                    for (const procId in this.state.processors) {
                        const processor = this.state.processors[procId];
                        if (processor.unlocked && processor.isActive) {
                            processor.currentProgress += deltaTime;
                            const actualProcessingTime = this.getActualProcessingTime(processor);
                            if (processor.currentProgress >= actualProcessingTime) {
                                this.state.resources[processor.outputResourceId].count += processor.outputAmountBase;
                                if (!this.state.resources[processor.outputResourceId].unlocked) {
                                    this.state.resources[processor.outputResourceId].unlocked = true;
                                    this.showToast(`${this.state.resources[processor.outputResourceId].name} now available!`);
                                }
                                this.showToast(`Processed 1 batch of ${this.state.resources[processor.outputResourceId].name}!`);
                                processor.isActive = false;
                                processor.currentProgress = 0;
                                this.checkAllAchievements(); 
                            }
                        }
                    }
                }
                if (this.state.research) {
                    for (const researchId in this.state.research) {
                        const researchItem = this.state.research[researchId];
                        if (researchItem.isResearching && !researchItem.unlocked) {
                            researchItem.currentProgress += deltaTime;
                            const actualResearchTime = this.getActualResearchTime(researchItem);
                            if (researchItem.currentProgress >= actualResearchTime) {
                                researchItem.unlocked = true;
                                researchItem.isResearching = false;
                                researchItem.currentProgress = actualResearchTime; 
                                this.showToast(`Research Complete: ${researchItem.name}!`, false, 5000); 
                                this.handleResearchCompletion(researchId);
                                this.checkAllAchievements();
                            }
                        }
                    }
                }


                this.state.lastUpdate = now; 
                this.checkAllAchievements(); 
                this.render(); 
            },

            manualMine(resourceId) {
                const resource = this.state.resources[resourceId];
                if (resource && resource.unlocked && resource.manualMineBaseAmount) { 
                    resource.count += this.getManualMineAmount(resource);
                    this.checkAllAchievements(); 
                    this.render();
                }
            },

            sellAllResources() { 
                let totalEarnings = 0;
                const heavenlyBonusMultiplier = 1 + (this.state.prestige.upgrades.heavenlyBonus.level * this.state.prestige.upgrades.heavenlyBonus.effectPerLevel);
                for (const resKey in this.state.resources) {
                    const resource = this.state.resources[resKey];
                    if (resource.unlocked && resource.count > 0) {
                        const valuePerUnit = resource.value * this.state.globalUpgrades.sellMultiplier.value * heavenlyBonusMultiplier;
                        totalEarnings += resource.count * valuePerUnit;
                        resource.count = 0;
                    }
                }
                this.state.money += totalEarnings;
                this.showToast(`Sold all resources for $${this.formatNumber(totalEarnings,2)}!`);
                this.checkAllAchievements();
                this.render();
                this.saveGame(true); 
            },
            
            sellResource(resourceId, quantity) {
                const numQuantity = parseFloat(quantity); // Use parseFloat for "all" which might be a large float
                if (isNaN(numQuantity) || numQuantity <= 0) {
                    this.showToast("Invalid quantity.", true);
                    return;
                }

                const resource = this.state.resources[resourceId];
                if (!resource || !resource.unlocked) {
                    this.showToast("Resource not available to sell.", true);
                    return;
                }
                if (resource.count < numQuantity) {
                    this.showToast(`Not enough ${resource.name} to sell.`, true);
                    return;
                }
                const heavenlyBonusMultiplier = 1 + (this.state.prestige.upgrades.heavenlyBonus.level * this.state.prestige.upgrades.heavenlyBonus.effectPerLevel);
                const valuePerUnit = resource.value * this.state.globalUpgrades.sellMultiplier.value * heavenlyBonusMultiplier;
                const earnings = numQuantity * valuePerUnit;

                resource.count -= numQuantity;
                this.state.money += earnings;
                this.state.stats.totalSoldViaMarketValue += earnings;
                this.state.stats.individualMarketSalesCount++;


                this.showToast(`Sold ${this.formatNumber(numQuantity)} ${resource.name} for $${this.formatNumber(earnings, 2)}!`);
                this.checkAllAchievements();
                this.render();
                this.saveGame(true);
            },


            getManualMineAmount(resource) {
                if (!resource || !resource.manualMineBaseAmount) return 0;
                const geologistBoost = this.state.globalUpgrades.masterGeologist.value;
                const manualBoost = this.state.globalUpgrades.manualMiningBoost.value;
                // Prestige does not directly boost manual mining in this iteration, but could be added
                return resource.manualMineBaseAmount * (1 + resource.manualMineLevel * 0.25) * manualBoost * geologistBoost;
            },
            getManualMineUpgradeCost(resource) {
                if (!resource || !resource.manualMineUpgradeCostBase) return Infinity;
                const efficiencyMultiplier = 1 - Math.min(this.state.globalUpgrades.efficiencyTraining.level * this.state.globalUpgrades.efficiencyTraining.increasePerLevel, 0.4); 
                return Math.floor(resource.manualMineUpgradeCostBase * Math.pow(1.25, resource.manualMineLevel) * efficiencyMultiplier);
            },
            buyManualMineUpgrade(resourceId) {
                const resource = this.state.resources[resourceId];
                if (!resource || !resource.manualMineUpgradeCostBase) { this.showToast("Cannot upgrade this item.", true); return; }
                const cost = this.getManualMineUpgradeCost(resource);
                if (this.state.money >= cost) {
                    this.state.money -= cost;
                    resource.manualMineLevel++;
                    this.showToast(`${resource.name} Click Power Lvl ${resource.manualMineLevel}!`);
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money!", true);
                }
            },

            getMinerCost(resource, forMinerNumber) { // forMinerNumber is 0-indexed for the next miner
                if (!resource || !resource.minerCostBase) return Infinity;
                const efficiencyMultiplier = 1 - Math.min(this.state.globalUpgrades.efficiencyTraining.level * this.state.globalUpgrades.efficiencyTraining.increasePerLevel, 0.4);
                return Math.floor(resource.minerCostBase * Math.pow(1.15, forMinerNumber) * efficiencyMultiplier);
            },

            buyMiner(resourceId, amountStr) {
                const resource = this.state.resources[resourceId];
                if (!resource || !resource.minerCostBase) { this.showToast("Cannot buy miners for this item.", true); return; }

                let amountToBuy;
                if (amountStr === 'max') {
                    let tempMoney = this.state.money;
                    let count = 0;
                    let costForNext = this.getMinerCost(resource, resource.miners + count);
                    while (tempMoney >= costForNext) {
                        tempMoney -= costForNext;
                        count++;
                        costForNext = this.getMinerCost(resource, resource.miners + count);
                    }
                    amountToBuy = count;
                } else {
                    amountToBuy = parseInt(amountStr);
                }

                if (isNaN(amountToBuy) || amountToBuy <= 0) {
                    // If max resulted in 0, don't show "Invalid amount", just that they can't afford any.
                    if (amountStr === 'max' && amountToBuy === 0) {
                         this.showToast("Cannot afford any more miners.", true);
                    } else {
                        this.showToast("Invalid amount.", true);
                    }
                    return;
                }

                let totalCost = 0;
                for (let i = 0; i < amountToBuy; i++) {
                    totalCost += this.getMinerCost(resource, resource.miners + i);
                }

                if (this.state.money >= totalCost) {
                    this.state.money -= totalCost;
                    resource.miners += amountToBuy;
                    this.showToast(`Bought ${amountToBuy} ${resource.name} Miner(s)! Total: ${resource.miners}`);
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money!", true);
                }
            },


            getMinerProduction(resource) {
                if (!resource || !resource.minerProductionBase) return 0; 
                const timeWarpMultiplier = 1 + (this.state.prestige.upgrades.timeWarp.level * this.state.prestige.upgrades.timeWarp.effectPerLevel);
                return resource.minerProductionBase * (1 + resource.minerSpeedLevel * 0.15) * this.state.globalUpgrades.minerSpeedBoost.value * timeWarpMultiplier;
            },
            getMinerSpeedUpgradeCost(resource) {
                if (!resource || !resource.minerSpeedUpgradeCostBase) return Infinity;
                const efficiencyMultiplier = 1 - Math.min(this.state.globalUpgrades.efficiencyTraining.level * this.state.globalUpgrades.efficiencyTraining.increasePerLevel, 0.4);
                return Math.floor(resource.minerSpeedUpgradeCostBase * Math.pow(1.3, resource.minerSpeedLevel) * efficiencyMultiplier);
            },
            buyMinerSpeedUpgrade(resourceId) {
                const resource = this.state.resources[resourceId];
                 if (!resource || !resource.minerSpeedUpgradeCostBase) { this.showToast("Cannot upgrade miner speed for this item.", true); return; }
                const cost = this.getMinerSpeedUpgradeCost(resource);
                if (this.state.money >= cost) {
                    this.state.money -= cost;
                    resource.minerSpeedLevel++;
                    this.showToast(`${resource.name} Miner Speed Lvl ${resource.minerSpeedLevel+1}!`); 
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money!", true);
                }
            },
            
            getGlobalUpgradeCost(upgradeKey) {
                const upgrade = this.state.globalUpgrades[upgradeKey];
                if (!upgrade) return Infinity;
                return Math.floor(upgrade.costBase * Math.pow(1.6 + (upgrade.increasePerLevel * 15) , upgrade.level)); 
            },
            buyGlobalUpgrade(upgradeKey) {
                const upgrade = this.state.globalUpgrades[upgradeKey];
                if (!upgrade) {
                    this.showToast("Upgrade not found!", true);
                    return;
                }
                const cost = this.getGlobalUpgradeCost(upgradeKey);
                if (this.state.money >= cost) {
                    this.state.money -= cost;
                    upgrade.level++;
                    if (upgradeKey === "researchAndDevelopment") {
                        upgrade.value = 1 - Math.min(upgrade.level * upgrade.increasePerLevel, 0.5); 
                    } else if (upgradeKey === "efficiencyTraining") {
                        upgrade.value = 1 - Math.min(upgrade.level * upgrade.increasePerLevel, 0.4);
                    } else {
                         upgrade.value = 1 + (upgrade.level * upgrade.increasePerLevel); 
                    }
                    this.showToast(`${upgrade.name} now Lvl ${upgrade.level}!`);
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money!", true);
                }
            },

            getUnlockRequirements(item) { 
                if (!item || !item.unlockRequirements) return null;
                const req = JSON.parse(JSON.stringify(item.unlockRequirements)); 
                const researchBonusMultiplier = 1 - Math.min(this.state.globalUpgrades.researchAndDevelopment.level * this.state.globalUpgrades.researchAndDevelopment.increasePerLevel, 0.5);

                if (req.money) {
                    req.money = Math.floor(req.money * researchBonusMultiplier);
                }
                if (req.resources) {
                    for (const resKey in req.resources) {
                        if (this.state.resources[resKey]) {
                             req.resources[resKey] = Math.floor(req.resources[resKey] * researchBonusMultiplier);
                        }
                    }
                }
                return req;
            },

            checkUnlockConditions(item) { 
                if (!item) return false; 
                const actualRequirements = this.getUnlockRequirements(item);
                if (!item.unlocked && actualRequirements) {
                    let canUnlock = true;
                    if (actualRequirements.money && this.state.money < actualRequirements.money) canUnlock = false;
                    if (actualRequirements.resources) {
                        for (const resKey in actualRequirements.resources) {
                            if (!this.state.resources[resKey] || this.state.resources[resKey].count < actualRequirements.resources[resKey]) {
                                canUnlock = false;
                                break;
                            }
                        }
                    }
                    return canUnlock;
                }
                return false; 
            },

            unlockItem(itemId, itemType = 'resource') { 
                const item = itemType === 'processor' ? this.state.processors[itemId] : this.state.resources[itemId];
                if (!item) { this.showToast(`${itemType === 'processor' ? 'Processor' : 'Resource'} to unlock not found!`, true); return; }

                const actualRequirements = this.getUnlockRequirements(item);

                if (item && !item.unlocked && actualRequirements && this.checkUnlockConditions(item)) { 
                    if (actualRequirements.money) this.state.money -= actualRequirements.money;
                    if (actualRequirements.resources) {
                        for (const resKey in actualRequirements.resources) {
                           if (this.state.resources[resKey]) this.state.resources[resKey].count -= actualRequirements.resources[resKey];
                        }
                    }
                    item.unlocked = true;
                    this.showToast(`${item.name} unlocked!`);
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast(`Cannot meet unlock requirements or ${itemType} already unlocked!`, true);
                }
            },

            getActualProcessingTime(processor) {
                if (!processor) return Infinity;
                const timeWarpMultiplier = 1 + (this.state.prestige.upgrades.timeWarp.level * this.state.prestige.upgrades.timeWarp.effectPerLevel);
                return Math.max(1, (processor.processingTimeBase * (1 - (processor.speedLevel * 0.05))) / timeWarpMultiplier); 
            },
            getActualInputAmounts(processor) { 
                if (!processor || !processor.inputs) return [];
                return processor.inputs.map(input => ({
                    id: input.id,
                    amount: Math.max(1, Math.ceil(input.amountBase * (1 - (processor.efficiencyLevel * 0.03))))
                }));
            },
            getActualCostToProcess(processor) {
                if (!processor) return Infinity;
                return Math.max(0, Math.ceil(processor.costToProcessBase * (1 - (processor.efficiencyLevel * 0.02)))); 
            },
            getProcessorUpgradeCost(processor, type) { 
                if (!processor) return Infinity;
                const level = type === 'speed' ? processor.speedLevel : processor.efficiencyLevel;
                const baseCost = type === 'speed' ? processor.speedUpgradeCostBase : processor.efficiencyUpgradeCostBase;
                return Math.floor(baseCost * Math.pow(1.4, level)); 
            },
            buyProcessorUpgrade(processorId, type) {
                const processor = this.state.processors[processorId];
                if (!processor) { this.showToast("Processor not found!", true); return; }
                const cost = this.getProcessorUpgradeCost(processor, type);
                if (this.state.money >= cost) {
                    this.state.money -= cost;
                    if (type === 'speed') {
                        processor.speedLevel++;
                        this.showToast(`${processor.name} Speed Lvl ${processor.speedLevel}!`);
                    } else if (type === 'efficiency') {
                        processor.efficiencyLevel++;
                        this.showToast(`${processor.name} Efficiency Lvl ${processor.efficiencyLevel}!`);
                    }
                    this.checkAllAchievements();
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough money for upgrade!", true);
                }
            },
            startProcessing(processorId) {
                const processor = this.state.processors[processorId];
                if (!processor || !processor.unlocked) { this.showToast("Processor not available!", true); return; }
                if (processor.isActive) { this.showToast(`${processor.name} is busy!`, true); return; }

                const actualInputAmounts = this.getActualInputAmounts(processor);
                const cost = this.getActualCostToProcess(processor);
                let canAffordAllInputs = true;
                let missingResourcesMessage = "Not enough: ";

                for (const input of actualInputAmounts) {
                    if (!this.state.resources[input.id] || this.state.resources[input.id].count < input.amount) {
                        canAffordAllInputs = false;
                        missingResourcesMessage += `${input.amount} ${this.state.resources[input.id]?.name || input.id}, `;
                    }
                }
                missingResourcesMessage = missingResourcesMessage.slice(0, -2); 

                if (!canAffordAllInputs) {
                    this.showToast(missingResourcesMessage, true);
                    return;
                }
                if (this.state.money < cost) {
                    this.showToast(`Not enough money for ${processor.name}! (Need $${this.formatNumber(cost)})`, true);
                    return;
                }

                for (const input of actualInputAmounts) {
                    this.state.resources[input.id].count -= input.amount;
                }
                this.state.money -= cost;

                processor.isActive = true;
                processor.currentProgress = 0;
                this.showToast(`Started processing 1 batch in ${processor.name}.`);
                this.render();
                this.saveGame(false); 
            },
            
            getActualResearchTime(researchItem) {
                if (!researchItem) return Infinity;
                const researchGrant = this.state.prestige.upgrades.researchGrant;
                const reduction = Math.min(researchGrant.level * researchGrant.effectPerLevel, 0.60); // Max 60% reduction
                return Math.max(1, researchItem.researchTimeBase * (1 - reduction));
            },

            startResearch(researchId) {
                const researchItem = this.state.research[researchId];
                if (!researchItem || researchItem.unlocked || researchItem.isResearching) {
                    this.showToast("Cannot start this research now.", true);
                    return;
                }

                const activeResearch = Object.values(this.state.research).find(r => r.isResearching);
                if (activeResearch) {
                    this.showToast(`Already researching ${activeResearch.name}. Finish or cancel it first.`, true);
                    return;
                }
                
                if (researchItem.requiresResearch && !this.state.research[researchItem.requiresResearch]?.unlocked) {
                    this.showToast(`Requires prior research: ${this.state.research[researchItem.requiresResearch]?.name || 'Unknown'}.`, true);
                    return;
                }


                let canAfford = true;
                let missingCost = "Need: ";
                if (this.state.money < researchItem.cost.money) {
                    canAfford = false;
                    missingCost += `$${this.formatNumber(researchItem.cost.money)}, `;
                }
                for (const resKey in researchItem.cost.resources) {
                    if (!this.state.resources[resKey] || this.state.resources[resKey].count < researchItem.cost.resources[resKey]) {
                        canAfford = false;
                        missingCost += `${this.formatNumber(researchItem.cost.resources[resKey])} ${this.state.resources[resKey]?.name || resKey}, `;
                    }
                }
                missingCost = missingCost.slice(0, -2);

                if (!canAfford) {
                    this.showToast(missingCost, true);
                    return;
                }

                this.state.money -= researchItem.cost.money;
                for (const resKey in researchItem.cost.resources) {
                    this.state.resources[resKey].count -= researchItem.cost.resources[resKey];
                }

                researchItem.isResearching = true;
                researchItem.currentProgress = 0;
                this.showToast(`Started research: ${researchItem.name}!`);
                this.render();
                this.saveGame(true);
            },

            handleResearchCompletion(researchId) {
                const researchItem = this.state.research[researchId];
                if (!researchItem || !researchItem.unlocked) return;

                if (researchItem.unlocksResource && this.state.resources[researchItem.unlocksResource]) {
                    this.state.resources[researchItem.unlocksResource].unlocked = true;
                    this.showToast(`${this.state.resources[researchItem.unlocksResource].name} can now be mined/acquired!`, false, 5000);
                }
                if (researchItem.unlocksProcessor && this.state.processors[researchItem.unlocksProcessor]) {
                    this.state.processors[researchItem.unlocksProcessor].unlocked = true;
                     this.showToast(`${this.state.processors[researchItem.unlocksProcessor].name} is now available!`, false, 5000);
                }
                this.render();
            },

            // --- Prestige System ---
            calculatePrestigePointsToGain() {
                const totalMoneyEver = this.state.money + this.state.stats.totalMoneyFromPreviousPrestiges;
                if (totalMoneyEver < this.state.prestige.minMoneyForPrestige) {
                    return 0;
                }
                const points = Math.floor(Math.pow(totalMoneyEver / 1e12, 0.5));
                return Math.max(0, points);
            },

            canPrestige() {
                const totalMoneyEver = this.state.money + this.state.stats.totalMoneyFromPreviousPrestiges;
                return totalMoneyEver >= this.state.prestige.minMoneyForPrestige && this.calculatePrestigePointsToGain() > 0;
            },

            performPrestige() {
                if (!this.canPrestige()) {
                    this.showToast("Not enough progress to Prestige yet!", true);
                    return;
                }
                const ppGained = this.calculatePrestigePointsToGain();
                this.showModal(
                    "Confirm Prestige",
                    `Are you sure you want to Prestige? You will gain ${this.formatNumber(ppGained)} Prestige Point(s). Most of your progress will be reset, but you will keep achievements and prestige upgrades.`,
                    () => {
                        this.resetState(true); // True for prestige reset
                        this.showToast(`Prestiged! Gained ${this.formatNumber(ppGained)} PP. Welcome to a new beginning!`, false, 7000);
                        this.switchTab('mines'); // Go to a relevant tab after prestige
                    }
                );
            },

            getPrestigeUpgradeCost(upgradeKey) {
                const upgrade = this.state.prestige.upgrades[upgradeKey];
                if (!upgrade) return Infinity;
                return Math.floor(upgrade.costBase * Math.pow(upgrade.costMultiplier, upgrade.level));
            },

            buyPrestigeUpgrade(upgradeKey) {
                const upgrade = this.state.prestige.upgrades[upgradeKey];
                if (!upgrade) {
                    this.showToast("Prestige upgrade not found!", true);
                    return;
                }
                const cost = this.getPrestigeUpgradeCost(upgradeKey);
                if (this.state.prestige.points >= cost) {
                    this.state.prestige.points -= cost;
                    upgrade.level++;
                    this.showToast(`${upgrade.name} upgraded to Lvl ${upgrade.level}!`, false);
                    this.render();
                    this.saveGame(true);
                } else {
                    this.showToast("Not enough Prestige Points!", true);
                }
            },


            downloadSaveFile() {
                try {
                    this.state.lastUpdate = Date.now(); 
                    const saveData = JSON.stringify(this.state, null, 2); 
                    const blob = new Blob([saveData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const now = new Date();
                    const dateStr = `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')}`;
                    const timeStr = `${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}`;
                    a.download = `MineTycoon_Save_${dateStr}_${timeStr}.json`; 
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    this.showToast("Save file downloaded!", false);
                } catch (error) {
                    console.error("Error downloading save file:", error);
                    this.showToast("Error downloading save file.", true);
                }
            },

            handleLoadSaveFile(event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedData = JSON.parse(e.target.result);
                        // Basic validation: Check if essential top-level keys exist
                        if (loadedData && loadedData.money !== undefined && loadedData.resources && loadedData.prestige && loadedData.globalUpgrades && loadedData.achievements && loadedData.investments && loadedData.processors && loadedData.research && loadedData.stats) {
                            
                            const defaultStateForMerging = this.getDefaultState();
                            this.applyLoadedState(loadedData, defaultStateForMerging); // Use helper

                            this.calculateOfflineProgression(this.state.lastUpdate); // Use lastUpdate from loaded save
                            this.checkAllAchievements(false); // Re-check achievements based on loaded state
                            this.render();
                            this.saveGame(true); // Save the newly loaded state to Firestore
                            this.showToast("Save file loaded successfully!", false);
                        } else {
                            this.showToast("Invalid save file format.", true);
                        }
                    } catch (error) {
                        console.error("Error parsing save file:", error);
                        this.showToast("Error loading save file. Make sure it's a valid JSON.", true);
                    } finally {
                        event.target.value = null; // Reset file input
                    }
                };
                reader.onerror = () => {
                    this.showToast("Error reading file.", true);
                     event.target.value = null; // Reset file input
                };
                reader.readAsText(file);
            },
            
            render() {
                if (!document.body || !document.getElementById('money-display') || !this.state || !this.state.resources || !this.state.globalUpgrades || !this.state.achievements || !this.state.investments || !this.state.processors || !this.state.stats || !this.state.research || !this.state.prestige) {
                    console.warn("Render called too early or critical elements/state missing. Deferring render.");
                    requestAnimationFrame(() => this.render());
                    return;
                }

                document.getElementById('money-display').textContent = `$${this.formatNumber(this.state.money, 2)}`;
                const heavenlyBonusMultiplier = 1 + (this.state.prestige.upgrades.heavenlyBonus.level * this.state.prestige.upgrades.heavenlyBonus.effectPerLevel);

                const resourcesContainer = document.getElementById('resources-container');
                if (resourcesContainer) {
                    resourcesContainer.innerHTML = ''; 
                    Object.values(this.state.resources).filter(res => (res.manualMineBaseAmount || res.unlocked) && (res.id !== 'element_x' || (res.id === 'element_x' && res.unlocked))).forEach(res => { 
                        if (!res) return; 
                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col'; 

                        if (!res.unlocked && res.unlockRequirements) { 
                            if (this.checkUnlockConditions(res)) { 
                                card.classList.add('border-2', 'border-green-500', 'cursor-pointer', 'hover:bg-slate-600'); 
                                card.innerHTML = this.createUnlockCardInnerHtml(res, 'resource');
                                card.querySelector('button[data-action="unlockItem"]')?.addEventListener('click', (e) => {
                                    e.stopPropagation(); 
                                    this.unlockItem(res.id, 'resource');
                                });
                            } else {
                                card.classList.add('opacity-70', 'bg-slate-800'); 
                                card.innerHTML = this.createLockedCardInnerHtml(res, 'resource');
                            }
                        } else if (res.unlocked) { 
                            let productionRate = (res.miners && res.miners > 0 && res.minerProductionBase) ? res.miners * this.getMinerProduction(res) : 0;
                            card.innerHTML = `
                                <div class="flex-grow"> 
                                    <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${res.name}</h3>
                                    <p class="text-xl sm:text-2xl my-1 sm:my-2">${this.formatNumber(res.count)}</p>
                                    <p class="text-xs sm:text-sm text-slate-400">Value: $${this.formatNumber(res.value * this.state.globalUpgrades.sellMultiplier.value * heavenlyBonusMultiplier, 2)}/unit</p>
                                    ${productionRate > 0 ? `<p class="text-xs sm:text-sm text-green-400">Prod: ${this.formatNumber(productionRate, 3)}/s</p>` : ''}
                                    ${!res.manualMineBaseAmount && !res.minerProductionBase ? '<p class="text-xs text-sky-400 italic">Processed Item</p>' : ''}
                                </div>
                                ${res.manualMineBaseAmount ? ` 
                                <div class="mt-auto"> 
                                    <button data-action="manualMine" data-resource="${res.id}" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-1.5 px-2 sm:py-2 sm:px-4 rounded-md transform hover:scale-105 transition-transform text-sm">Mine ${this.formatNumber(this.getManualMineAmount(res),1)}</button>
                                    <div class="mt-2 sm:mt-3 pt-2 sm:pt-3 border-t border-slate-600">
                                        <p class="text-xs sm:text-sm text-slate-300 mb-1">Click Lvl: ${res.manualMineLevel}</p>
                                        <button data-action="buyManualMineUpgrade" data-resource="${res.id}" class="w-full text-xs sm:text-sm bg-green-500 hover:bg-green-600 text-white py-1 px-1.5 sm:py-1 sm:px-2 rounded-md transform hover:scale-105 transition-transform">Upgrade ($${this.formatNumber(this.getManualMineUpgradeCost(res))})</button>
                                    </div>
                                    <div class="mt-2 sm:mt-3 pt-2 sm:pt-3 border-t border-slate-600">
                                        <p class="text-xs sm:text-sm text-slate-300 mb-1">Miners: ${res.miners} (Speed Lvl ${res.minerSpeedLevel + 1})</p>
                                        <div class="flex space-x-1 mb-1">
                                            <button data-action="buyMiner" data-resourceid="${res.id}" data-amount="1" class="flex-1 text-xs bg-purple-500 hover:bg-purple-600 text-white py-1 px-1 rounded-md">x1</button>
                                            <button data-action="buyMiner" data-resourceid="${res.id}" data-amount="10" class="flex-1 text-xs bg-purple-500 hover:bg-purple-600 text-white py-1 px-1 rounded-md">x10</button>
                                            <button data-action="buyMiner" data-resourceid="${res.id}" data-amount="100" class="flex-1 text-xs bg-purple-500 hover:bg-purple-600 text-white py-1 px-1 rounded-md">x100</button>
                                            <button data-action="buyMiner" data-resourceid="${res.id}" data-amount="max" class="flex-1 text-xs bg-purple-500 hover:bg-purple-600 text-white py-1 px-1 rounded-md">Max</button>
                                        </div>
                                        <p class="text-xs text-slate-400 mb-1 text-center">Cost for next: $${this.formatNumber(this.getMinerCost(res, res.miners))}</p>
                                        <button data-action="buyMinerSpeedUpgrade" data-resource="${res.id}" class="w-full text-xs sm:text-sm bg-teal-500 hover:bg-teal-600 text-white py-1 px-1.5 sm:py-1 sm:px-2 rounded-md transform hover:scale-105 transition-transform">Upgrade Speed ($${this.formatNumber(this.getMinerSpeedUpgradeCost(res))})</button>
                                    </div>
                                </div>` : '' }`;
                        } else { 
                             card.innerHTML = `<h3 class="text-lg sm:text-xl font-semibold text-slate-500">${res.name} (Research Required)</h3>`;
                             card.classList.add('opacity-50', 'bg-slate-800');
                        }
                        resourcesContainer.appendChild(card);
                    });
                }


                const globalUpgradesContainer = document.getElementById('global-upgrades-container');
                if (globalUpgradesContainer) {
                    globalUpgradesContainer.innerHTML = '';
                    for (const upgradeKey in this.state.globalUpgrades) {
                        const upgrade = this.state.globalUpgrades[upgradeKey];
                        if (!upgrade) continue; 
                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col justify-between'; 
                        let effectDesc = upgrade.description || ""; 
                        let currentEffect = "";
                        if (upgradeKey === "sellMultiplier" || upgradeKey === "minerSpeedBoost" || upgradeKey === "manualMiningBoost" || upgradeKey === "masterGeologist") {
                             currentEffect = `${( (1 + upgrade.level * upgrade.increasePerLevel) * 100 - 100).toFixed(1)}% Bonus`; 
                        } else if (upgradeKey === "researchAndDevelopment") {
                            currentEffect = `${Math.min(upgrade.level * upgrade.increasePerLevel * 100, 50).toFixed(1)}% Cost Reduction`;
                        } else if (upgradeKey === "efficiencyTraining") {
                            currentEffect = `${Math.min(upgrade.level * upgrade.increasePerLevel * 100, 40).toFixed(1)}% Cost Reduction`;
                        }
                        card.innerHTML = `
                            <div class="flex-grow">
                                <h3 class="text-md sm:text-lg font-semibold text-yellow-400">${upgrade.name}</h3>
                                <p class="text-xs sm:text-sm text-slate-300 my-1">${effectDesc}</p>
                                <p class="text-sm sm:text-base my-1 text-sky-300">Current: ${currentEffect}</p>
                                <p class="text-xs sm:text-sm text-slate-400 mb-2">Level: ${upgrade.level}</p>
                            </div>
                            <button data-action="buyGlobalUpgrade" data-upgradekey="${upgradeKey}" class="mt-auto w-full bg-orange-500 hover:bg-orange-600 text-white font-medium py-1.5 px-2 sm:py-2 sm:px-4 rounded-md transform hover:scale-105 transition-transform text-sm">Upgrade ($${this.formatNumber(this.getGlobalUpgradeCost(upgradeKey))})</button>`;
                        globalUpgradesContainer.appendChild(card);
                    }
                }
                
                const processorsContainer = document.getElementById('processors-container');
                if (processorsContainer) {
                    processorsContainer.innerHTML = '';
                    for (const procId in this.state.processors) {
                        const processor = this.state.processors[procId];
                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col';

                        if (!processor.unlocked) {
                            let researchPrerequisiteMet = true;
                            let researchPrerequisiteText = "";
                            if (processor.unlockRequirements === null) { 
                                const researchLink = Object.values(this.state.research).find(r => r.unlocksProcessor === procId);
                                if (researchLink && !researchLink.unlocked) {
                                    researchPrerequisiteMet = false;
                                    researchPrerequisiteText = `<p class="text-xs text-red-400 mt-1">Requires Research: ${researchLink.name}</p>`;
                                } else if (!researchLink) { 
                                     researchPrerequisiteMet = false;
                                     researchPrerequisiteText = `<p class="text-xs text-red-400 mt-1">Error: Linked research not found.</p>`;
                                }
                            }

                            if (researchPrerequisiteMet && this.checkUnlockConditions(processor)) {
                                card.classList.add('border-2', 'border-green-500', 'cursor-pointer', 'hover:bg-slate-600');
                                card.innerHTML = this.createUnlockCardInnerHtml(processor, 'processor');
                                 card.querySelector('button[data-action="unlockItem"]')?.addEventListener('click', (e) => {
                                    e.stopPropagation(); 
                                    this.unlockItem(processor.id, 'processor');
                                });
                            } else {
                                card.classList.add('opacity-70', 'bg-slate-800');
                                card.innerHTML = this.createLockedCardInnerHtml(processor, 'processor', researchPrerequisiteText);
                            }
                        } else {
                            const actualInputAmounts = this.getActualInputAmounts(processor); 
                            const outputRes = this.state.resources[processor.outputResourceId];
                            const actualProcessingTime = this.getActualProcessingTime(processor);
                            const actualCostToProcess = this.getActualCostToProcess(processor);
                            const progressPercent = processor.isActive ? (processor.currentProgress / actualProcessingTime) * 100 : 0;

                            let inputsHtml = actualInputAmounts.map(input => {
                                const inputResDef = this.state.resources[input.id];
                                return `${this.formatNumber(input.amount)} ${inputResDef.name}`;
                            }).join(' + ');

                            card.innerHTML = `
                                <div class="flex-grow">
                                    <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${processor.name}</h3>
                                    <p class="text-xs sm:text-sm text-slate-300">Converts: ${inputsHtml} &rarr; ${processor.outputAmountBase} ${outputRes.name}</p>
                                    <p class="text-xs sm:text-sm text-slate-400">Time: ${this.formatNumber(actualProcessingTime, 1)}s | Cost: $${this.formatNumber(actualCostToProcess)}</p>
                                    
                                    ${processor.isActive ? `
                                    <div class="w-full bg-slate-600 rounded-full h-2.5 my-2">
                                        <div class="bg-blue-500 h-2.5 rounded-full" style="width: ${progressPercent}%"></div>
                                    </div>
                                    <p class="text-xs text-center text-blue-300">Processing... (${this.formatNumber(Math.max(0, actualProcessingTime - processor.currentProgress), 1)}s left)</p>
                                    ` : `
                                    <button data-action="startProcessing" data-processorid="${procId}" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-1.5 px-2 rounded-md transform hover:scale-105 transition-transform text-sm ${processor.isActive ? 'opacity-50 cursor-not-allowed' : ''}" ${processor.isActive ? 'disabled' : ''}>
                                        Process Batch
                                    </button>
                                    `}
                                </div>
                                <div class="mt-auto pt-2 sm:pt-3 border-t border-slate-600">
                                    <p class="text-xs text-slate-300 mb-1">Speed Lvl: ${processor.speedLevel} | Efficiency Lvl: ${processor.efficiencyLevel}</p>
                                    <div class="flex space-x-2">
                                        <button data-action="buyProcessorUpgrade" data-processorid="${procId}" data-upgradetype="speed" class="flex-1 text-xs bg-green-500 hover:bg-green-600 text-white py-1 px-1.5 rounded-md transform hover:scale-105 transition-transform">Speed ($${this.formatNumber(this.getProcessorUpgradeCost(processor, 'speed'))})</button>
                                        <button data-action="buyProcessorUpgrade" data-processorid="${procId}" data-upgradetype="efficiency" class="flex-1 text-xs bg-teal-500 hover:bg-teal-600 text-white py-1 px-1.5 rounded-md transform hover:scale-105 transition-transform">Efficiency ($${this.formatNumber(this.getProcessorUpgradeCost(processor, 'efficiency'))})</button>
                                    </div>
                                </div>
                            `;
                        }
                        processorsContainer.appendChild(card);
                    }
                }

                const marketContainer = document.getElementById('market-container');
                if (marketContainer) {
                    marketContainer.innerHTML = '';
                    Object.values(this.state.resources).filter(res => res.unlocked && res.value > 0).sort((a,b) => a.name.localeCompare(b.name)).forEach(res => {
                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col';
                        const currentPrice = res.value * this.state.globalUpgrades.sellMultiplier.value * heavenlyBonusMultiplier;
                        card.innerHTML = `
                            <div class="flex-grow">
                                <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${res.name}</h3>
                                <p class="text-sm text-slate-300">In Stock: ${this.formatNumber(res.count)}</p>
                                <p class="text-xs text-slate-400 mb-2">Sell Price: $${this.formatNumber(currentPrice, 2)}/unit</p>
                                <input type="number" id="sell-amount-${res.id}" class="bg-slate-800 border border-slate-600 text-white text-sm rounded-md p-2 w-full mb-2 focus:ring-sky-500 focus:border-sky-500" placeholder="Qty to sell" min="1" max="${Math.floor(res.count)}">
                            </div>
                            <div class="mt-auto space-y-1">
                                <div class="flex space-x-1">
                                    ${res.count >= 1 ? `<button data-action="sellResource" data-resourceid="${res.id}" data-sellamount="1" class="flex-1 text-xs bg-sky-600 hover:bg-sky-700 text-white py-1 px-1.5 rounded-md">Sell 1</button>` : ''}
                                    ${res.count >= 10 ? `<button data-action="sellResource" data-resourceid="${res.id}" data-sellamount="10" class="flex-1 text-xs bg-sky-600 hover:bg-sky-700 text-white py-1 px-1.5 rounded-md">Sell 10</button>` : ''}
                                    ${res.count >= 100 ? `<button data-action="sellResource" data-resourceid="${res.id}" data-sellamount="100" class="flex-1 text-xs bg-sky-600 hover:bg-sky-700 text-white py-1 px-1.5 rounded-md">Sell 100</button>` : ''}
                                </div>
                                <button data-action="sellResourceCustom" data-resourceid="${res.id}" class="w-full bg-green-500 hover:bg-green-600 text-white font-medium py-1.5 px-2 rounded-md text-sm">Sell Custom</button>
                                <button data-action="sellResource" data-resourceid="${res.id}" data-sellamount="${res.count}" class="w-full bg-yellow-500 hover:bg-yellow-600 text-slate-900 font-medium py-1.5 px-2 rounded-md text-sm">Sell All (${this.formatNumber(res.count)})</button>
                            </div>
                        `;
                        marketContainer.appendChild(card);
                    });
                }

                const researchContainer = document.getElementById('research-container');
                if (researchContainer) {
                    researchContainer.innerHTML = '';
                    for (const researchId in this.state.research) {
                        const item = this.state.research[researchId];
                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col';
                        
                        let costHtml = `Cost: $${this.formatNumber(item.cost.money)}`;
                        if (item.cost.resources) {
                            for (const resKey in item.cost.resources) {
                                costHtml += `, ${this.formatNumber(item.cost.resources[resKey])} ${this.state.resources[resKey]?.name || resKey}`;
                            }
                        }
                        
                        let prerequisiteMet = true;
                        let prerequisiteText = "";
                        if (item.requiresResearch) {
                            const prereq = this.state.research[item.requiresResearch];
                            if (!prereq || !prereq.unlocked) {
                                prerequisiteMet = false;
                                prerequisiteText = `<p class="text-xs text-red-400 mt-1">Requires: ${prereq?.name || 'Previous Research'}</p>`;
                            }
                        }
                        const actualResearchTime = this.getActualResearchTime(item);
                        let buttonHtml = '';
                        if (item.unlocked) {
                            buttonHtml = '<p class="text-center text-green-400 font-semibold mt-2 py-1.5">Research Complete!</p>';
                        } else if (item.isResearching) {
                            const progressPercent = (item.currentProgress / actualResearchTime) * 100;
                            buttonHtml = `
                                <div class="w-full bg-slate-600 rounded-full h-4 my-2">
                                    <div class="bg-sky-500 h-4 rounded-full text-xs font-medium text-blue-100 text-center p-0.5 leading-none" style="width: ${progressPercent}%">${Math.floor(progressPercent)}%</div>
                                </div>
                                <p class="text-xs text-center text-sky-300">Researching... (${this.formatNumber(actualResearchTime - item.currentProgress, 0)}s left)</p>
                            `;
                        } else if (!prerequisiteMet) {
                             buttonHtml = `<button class="mt-2 w-full bg-slate-500 text-slate-400 font-medium py-1.5 px-2 rounded-md text-sm cursor-not-allowed" disabled>Start Research</button>`;
                        }
                        else {
                            buttonHtml = `<button data-action="startResearch" data-researchid="${researchId}" class="mt-2 w-full bg-sky-500 hover:bg-sky-600 text-white font-medium py-1.5 px-2 rounded-md transform hover:scale-105 transition-transform text-sm">Start Research</button>`;
                        }

                        card.innerHTML = `
                            <div class="flex-grow">
                                <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${item.name}</h3>
                                <p class="text-xs sm:text-sm text-slate-300 my-1">${item.description}</p>
                                <p class="text-xs sm:text-sm text-slate-400">${costHtml}</p>
                                <p class="text-xs sm:text-sm text-slate-400">Time: ${this.formatNumber(actualResearchTime,1)}s</p>
                                ${prerequisiteText}
                            </div>
                            <div class="mt-auto pt-2 sm:pt-3">
                                ${buttonHtml}
                            </div>
                        `;
                        researchContainer.appendChild(card);
                    }
                }


                const achievementsContainer = document.getElementById('achievements-container');
                if (achievementsContainer) {
                    achievementsContainer.innerHTML = '';
                    const categories = {};
                    Object.entries(this.achievementsList).forEach(([id, achDef]) => {
                        if (!achDef || !achDef.category) return; 
                        if (!categories[achDef.category]) categories[achDef.category] = [];
                        categories[achDef.category].push({id, ...achDef, outputResourceId: achDef.outputResourceId}); 
                    });

                    for (const categoryName in categories) {
                        const categoryDiv = document.createElement('div');
                        categoryDiv.className = 'mb-6 sm:mb-8'; 
                        categoryDiv.innerHTML = `<h3 class="text-xl sm:text-2xl font-semibold text-sky-300 mb-3 sm:mb-4 border-b-2 border-sky-700 pb-2">${categoryName}</h3>`; 
                        const gridDiv = document.createElement('div');
                        gridDiv.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4';
                        
                        categories[categoryName].sort((a,b) => { 
                            const aUnlocked = this.state.achievements[a.id]?.unlocked;
                            const bUnlocked = this.state.achievements[b.id]?.unlocked;
                            if (aUnlocked && !bUnlocked) return -1;
                            if (!aUnlocked && bUnlocked) return 1;
                            return a.name.localeCompare(b.name); 
                        }).forEach(ach => {
                            const achState = this.state.achievements[ach.id];
                            const card = document.createElement('div');
                            card.className = `p-3 sm:p-4 rounded-lg shadow-lg flex flex-col ${achState?.unlocked ? 'bg-green-600 border-2 border-green-400' : 'bg-slate-700 opacity-90'}`; 
                            card.innerHTML = `
                                <div class="flex-grow">
                                    <h4 class="text-base sm:text-lg font-semibold ${achState?.unlocked ? 'text-yellow-200' : 'text-yellow-400'}">${ach.name}</h4>
                                    <p class="text-xs sm:text-sm mt-1 ${achState?.unlocked ? 'text-green-100' : 'text-slate-300'}">${ach.description}</p>
                                </div>
                                ${achState?.unlocked && achState.unlockedAt ? `<p class="text-xs italic mt-2 pt-2 border-t border-green-500 ${achState?.unlocked ? 'text-green-200' : 'text-slate-500'}">Unlocked: ${new Date(achState.unlockedAt).toLocaleDateString()}</p>` : ''}
                            `;
                            gridDiv.appendChild(card);
                        });
                        categoryDiv.appendChild(gridDiv);
                        achievementsContainer.appendChild(categoryDiv);
                    }
                }

                const investmentsContainer = document.getElementById('investments-container');
                if (investmentsContainer) {
                    investmentsContainer.innerHTML = '';
                    let totalPortfolioValue = 0;
                    for (const assetId in this.investableAssets) {
                        const assetDef = this.investableAssets[assetId];
                        const marketData = this.state.investments.market[assetId];
                        const portfolioData = this.state.investments.portfolio[assetId];
                        if (!assetDef || !marketData || !portfolioData) continue; 

                        const currentAssetValue = marketData.currentPrice * portfolioData.shares;
                        totalPortfolioValue += currentAssetValue;

                        const card = document.createElement('div');
                        card.className = 'bg-slate-700 p-3 sm:p-4 rounded-lg shadow-md flex flex-col';
                        card.innerHTML = `
                            <div class="flex-grow">
                                <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${assetDef.name}</h3>
                                <p class="text-xl sm:text-2xl my-1 sm:my-2">Price: $${this.formatNumber(marketData.currentPrice, 2)} ${marketData.trendArrow || '&#8212;'}</p>
                                <p class="text-xs sm:text-sm text-slate-400">Last: $${this.formatNumber(marketData.lastPrice, 2)}</p>
                                <hr class="my-2 sm:my-3 border-slate-600">
                                <p class="text-base sm:text-lg font-medium">Your Portfolio:</p>
                                <p class="text-xs sm:text-sm">Shares: ${this.formatNumber(portfolioData.shares)}</p>
                                <p class="text-xs sm:text-sm">Avg. Buy: $${this.formatNumber(portfolioData.avgBuyPrice, 2)}</p>
                                <p class="text-xs sm:text-sm">Value: $${this.formatNumber(currentAssetValue, 2)}</p>
                            </div>
                            <div class="mt-auto pt-2 sm:pt-3 border-t border-slate-600">
                                <div class="flex space-x-2 mb-2">
                                    <input type="number" id="buy-${assetId}-amount" class="bg-slate-800 border border-slate-600 text-white text-xs sm:text-sm rounded-md p-1.5 sm:p-2 w-full focus:ring-sky-500 focus:border-sky-500" placeholder="Qty" min="1">
                                    <button data-action="buyShares" data-assetid="${assetId}" class="bg-green-500 hover:bg-green-600 text-white font-medium py-1.5 px-2 sm:py-2 sm:px-3 rounded-md transform hover:scale-105 transition-transform text-xs sm:text-sm">Buy</button>
                                </div>
                                <div class="flex space-x-2">
                                    <input type="number" id="sell-${assetId}-amount" class="bg-slate-800 border border-slate-600 text-white text-xs sm:text-sm rounded-md p-1.5 sm:p-2 w-full focus:ring-sky-500 focus:border-sky-500" placeholder="Qty" min="1">
                                    <button data-action="sellShares" data-assetid="${assetId}" class="bg-red-500 hover:bg-red-600 text-white font-medium py-1.5 px-2 sm:py-2 sm:px-3 rounded-md transform hover:scale-105 transition-transform text-xs sm:text-sm">Sell</button>
                                </div>
                            </div>
                        `;
                        investmentsContainer.appendChild(card);
                    }
                    const portfolioSummary = document.getElementById('portfolio-summary');
                    if (portfolioSummary) {
                         const currentTotalPortfolioValue = Object.keys(this.state.investments.portfolio).reduce((sum, assetId) => {
                            const p = this.state.investments.portfolio[assetId];
                            const m = this.state.investments.market[assetId];
                            if (p && m) {
                                return sum + (p.shares * m.currentPrice);
                            }
                            return sum;
                        }, 0);

                        const totalCostOfCurrentShares = Object.values(this.state.investments.portfolio).reduce((sum,p) => sum + (p.shares * p.avgBuyPrice), 0);
                        const unrealizedPL = currentTotalPortfolioValue - totalCostOfCurrentShares;
                        const realizedPL = (this.state.investments.totalSoldValue || 0) - (this.state.investments.totalBoughtValue || 0);


                        portfolioSummary.innerHTML = `
                            <p class="text-base sm:text-lg">Total Portfolio Value: <span class="font-semibold text-sky-400">$${this.formatNumber(totalPortfolioValue, 2)}</span></p>
                            <p class="text-xs sm:text-sm">Unrealized P/L: <span class="${unrealizedPL >= 0 ? 'text-green-400' : 'text-red-400'}">$${this.formatNumber(unrealizedPL, 2)}</span></p>
                            <p class="text-xs sm:text-sm">Realized P/L: <span class="${realizedPL >= 0 ? 'text-green-400' : 'text-red-400'}">$${this.formatNumber(realizedPL, 2)}</span></p>
                            <p class="text-xs text-slate-500 mt-1">Transaction Fee: ${this.state.investments.transactionFee * 100}% (applied on buy/sell)</p>
                        `;
                    }
                }

                // Render Prestige Tab
                const prestigeTabContent = document.getElementById('prestige-tab-content');
                if (prestigeTabContent) {
                    const prestige = this.state.prestige;
                    const totalMoneyEver = this.state.money + this.state.stats.totalMoneyFromPreviousPrestiges; // Defined for this scope
                    const ppToGain = this.calculatePrestigePointsToGain();
                    const canPrestigeNow = this.canPrestige();
                    let prestigeInfoHtml = `
                        <p class="text-lg text-center mb-2">Prestige Points (PP): <span class="font-bold text-yellow-400">${this.formatNumber(prestige.points)}</span></p>
                        <p class="text-sm text-center mb-1">Total PP Earned: ${this.formatNumber(prestige.totalPointsEverEarned)}</p>
                        <p class="text-sm text-center mb-4">Prestiges Done: ${this.formatNumber(prestige.prestigesDone)}</p>
                        <div class="text-center mb-6">
                            <p class="text-md mb-2">On next Prestige, you will gain: <span class="font-bold text-xl ${ppToGain > 0 ? 'text-green-400' : 'text-slate-400'}">${this.formatNumber(ppToGain)} PP</span></p>
                            <button data-action="performPrestige" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2.5 px-6 rounded-lg shadow-lg text-lg transform hover:scale-105 transition-transform ${!canPrestigeNow ? 'opacity-50 cursor-not-allowed' : ''}" ${!canPrestigeNow ? 'disabled' : ''}>
                                Perform Prestige
                            </button>
                            ${!canPrestigeNow && totalMoneyEver < prestige.minMoneyForPrestige ? `<p class="text-xs text-red-400 mt-1">Reach $${this.formatNumber(prestige.minMoneyForPrestige)} total earnings to unlock Prestige.</p>` : ''}
                             ${!canPrestigeNow && totalMoneyEver >= prestige.minMoneyForPrestige && ppToGain === 0 ? `<p class="text-xs text-yellow-400 mt-1">Earn more to gain Prestige Points.</p>` : ''}
                        </div>
                        <h3 class="text-xl font-semibold text-sky-300 mb-4 text-center border-t border-slate-700 pt-4">Prestige Upgrades</h3>
                        <div id="prestige-upgrades-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">`;

                    for (const upgKey in prestige.upgrades) {
                        const upgrade = prestige.upgrades[upgKey];
                        const cost = this.getPrestigeUpgradeCost(upgKey);
                        prestigeInfoHtml += `
                            <div class="bg-slate-800 p-4 rounded-lg shadow-md">
                                <h4 class="text-lg font-semibold text-yellow-500">${upgrade.name} <span class="text-sm text-slate-400">(Lvl ${upgrade.level})</span></h4>
                                <p class="text-xs text-slate-300 my-1">${upgrade.description}</p>
                                <p class="text-sm text-sky-400">Cost: ${this.formatNumber(cost)} PP</p>
                                <button data-action="buyPrestigeUpgrade" data-upgradekey="${upgKey}" class="mt-2 w-full bg-green-500 hover:bg-green-600 text-white font-medium py-1.5 px-3 rounded-md text-sm ${prestige.points < cost ? 'opacity-50 cursor-not-allowed' : 'transform hover:scale-105 transition-transform'}" ${prestige.points < cost ? 'disabled' : ''}>
                                    Upgrade
                                </button>
                            </div>`;
                    }
                    prestigeInfoHtml += `</div>`;
                    prestigeTabContent.innerHTML = prestigeInfoHtml;
                }
                
                document.getElementById('mines-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'mines');
                document.getElementById('upgrades-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'upgrades');
                document.getElementById('investments-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'investments');
                document.getElementById('achievements-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'achievements');
                document.getElementById('process-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'process');
                document.getElementById('market-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'market');
                document.getElementById('research-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'research');
                document.getElementById('prestige-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'prestige');
                document.getElementById('settings-tab-content')?.classList.toggle('hidden', this.state.currentTab !== 'settings');


                document.querySelectorAll('button[data-tab]').forEach(tabButton => {
                    tabButton.classList.toggle('bg-sky-600', tabButton.dataset.tab === this.state.currentTab); 
                    tabButton.classList.toggle('text-white', tabButton.dataset.tab === this.state.currentTab);
                    tabButton.classList.toggle('bg-sky-800', tabButton.dataset.tab !== this.state.currentTab); 
                    tabButton.classList.toggle('text-sky-200', tabButton.dataset.tab !== this.state.currentTab); 
                    tabButton.classList.toggle('hover:bg-sky-500', tabButton.dataset.tab !== this.state.currentTab); 
                    tabButton.classList.toggle('hover:bg-sky-600', tabButton.dataset.tab === this.state.currentTab); 
                });
            },
            
            createUnlockCardInnerHtml(item, itemType = 'resource') { 
                let requirementsText = "Requires: ";
                const actualRequirements = this.getUnlockRequirements(item);
                if (!item || !actualRequirements) return "<p>Error loading requirements.</p>"; 
                
                const reqParts = [];
                if (actualRequirements.money) reqParts.push(`$${this.formatNumber(actualRequirements.money)}`);
                if (actualRequirements.resources) {
                    reqParts.push(...Object.entries(actualRequirements.resources)
                        .map(([key, val]) => {
                            const reqResource = this.state.resources[key];
                            return `${this.formatNumber(val)} ${reqResource ? reqResource.name : key}`;
                        }));
                }
                requirementsText += reqParts.join(', ');

                return `
                    <div class="flex-grow">
                        <h3 class="text-lg sm:text-xl font-semibold text-yellow-400">${item.name} (Locked)</h3>
                        <p class="text-xs sm:text-sm text-slate-400 my-1 sm:my-2">${requirementsText}</p>
                    </div>
                    <button data-action="unlockItem" data-itemid="${item.id}" data-itemtype="${itemType}" class="mt-auto w-full bg-green-500 hover:bg-green-600 text-white font-medium py-1.5 px-2 sm:py-2 sm:px-4 rounded-md transform hover:scale-105 transition-transform text-sm">Unlock ${item.name}</button>`;
            },

            createLockedCardInnerHtml(item, itemType = 'resource', prerequisiteText = '') { 
                let requirementsText = "Requires: ";
                const actualRequirements = this.getUnlockRequirements(item);
                
                if (!actualRequirements && prerequisiteText) {
                     requirementsText = prerequisiteText;
                } else if (!item || !actualRequirements) {
                    return "<p>Error loading requirements.</p>"; 
                } else {
                    const reqParts = [];
                    if (actualRequirements.money) reqParts.push(`$${this.formatNumber(actualRequirements.money)}`);
                    if (actualRequirements.resources) {
                         reqParts.push(...Object.entries(actualRequirements.resources)
                            .map(([key, val]) => {
                                const reqResource = this.state.resources[key];
                                return `${this.formatNumber(val)} ${reqResource ? reqResource.name : key}`;
                            }));
                    }
                     requirementsText += reqParts.join(', ');
                }


                return `
                    <div class="flex-grow">
                        <h3 class="text-lg sm:text-xl font-semibold text-slate-500">${item.name} (Locked)</h3>
                        <p class="text-xs sm:text-sm text-slate-400 my-1 sm:my-2">${requirementsText}</p>
                    </div>
                    <p class="text-center text-slate-500 italic mt-auto text-xs sm:text-sm">Meet requirements to unlock.</p>`;
            },

            setupEventListeners() {
                document.body.addEventListener('click', (event) => {
                    const target = event.target.closest('button[data-action]');
                    if (!target) return;

                    const action = target.dataset.action;
                    const resourceId = target.dataset.resourceid; 
                    const upgradeKey = target.dataset.upgradekey; 
                    const assetId = target.dataset.assetid; 
                    const processorId = target.dataset.processorid;
                    const upgradeType = target.dataset.upgradetype;
                    const itemId = target.dataset.itemid;
                    const itemType = target.dataset.itemtype;
                    const sellAmount = target.dataset.sellamount;
                    const researchId = target.dataset.researchid;
                    const buyAmount = target.dataset.amount; // For bulk buy miners


                    if (action === 'manualMine') this.manualMine(target.dataset.resource); 
                    else if (action === 'buyManualMineUpgrade') this.buyManualMineUpgrade(target.dataset.resource);
                    else if (action === 'buyMiner') this.buyMiner(resourceId, buyAmount); // Updated for bulk buy
                    else if (action === 'buyMinerSpeedUpgrade') this.buyMinerSpeedUpgrade(target.dataset.resource);
                    else if (action === 'sellAllResources') this.sellAllResources();
                    else if (action === 'buyGlobalUpgrade') this.buyGlobalUpgrade(upgradeKey); 
                    else if (action === 'unlockItem') this.unlockItem(itemId, itemType); 
                    else if (action === 'resetGame') this.confirmResetGame(); 
                    else if (action === 'downloadSave') this.downloadSaveFile(); 
                    else if (action === 'startResearch') this.startResearch(researchId);
                    else if (action === 'performPrestige') this.performPrestige();
                    else if (action === 'buyPrestigeUpgrade') this.buyPrestigeUpgrade(upgradeKey);
                    else if (action === 'buyShares') {
                        const amountInput = document.getElementById(`buy-${assetId}-amount`);
                        if (amountInput) {
                            this.buyShares(assetId, amountInput.value);
                            amountInput.value = ''; 
                        }
                    } else if (action === 'sellShares') {
                        const amountInput = document.getElementById(`sell-${assetId}-amount`);
                        if (amountInput) {
                            this.sellShares(assetId, amountInput.value);
                            amountInput.value = ''; 
                        }
                    } else if (action === 'startProcessing') this.startProcessing(processorId);
                    else if (action === 'buyProcessorUpgrade') this.buyProcessorUpgrade(processorId, upgradeType);
                    else if (action === 'sellResource') {
                        this.sellResource(resourceId, sellAmount);
                    } else if (action === 'sellResourceCustom') {
                        const amountInput = document.getElementById(`sell-amount-${resourceId}`);
                        if (amountInput && amountInput.value) {
                            this.sellResource(resourceId, amountInput.value);
                            amountInput.value = ''; 
                        } else {
                            this.showToast("Please enter a quantity to sell.", true);
                        }
                    }
                });
                 
                document.querySelectorAll('button[data-tab]').forEach(button => {
                    button.addEventListener('click', () => this.switchTab(button.dataset.tab));
                });

                // Event listener for the new file input
                const loadSaveInput = document.getElementById('load-save-input');
                if (loadSaveInput) {
                    loadSaveInput.addEventListener('change', (event) => this.handleLoadSaveFile(event));
                }
            },
            
            switchTab(tabId) {
                if(tabId && this.state.currentTab !== tabId) { 
                    this.state.currentTab = tabId;
                    this.render(); 
                }
            },

            confirmResetGame() { 
                this.showModal(
                    "Confirm Reset", 
                    "Are you sure you want to reset all your game progress? This action cannot be undone. This will reset EVERYTHING, including Prestige progress.",
                    async () => { 
                        this.resetState(false); // false for hard reset
                        this.showToast("Game has been reset!", false);
                    }
                );
            },

            formatNumber(num, precision = 0) {
                if (num === undefined || num === null || isNaN(parseFloat(num))) return '0'; 
                const numFloat = parseFloat(num);

                if (numFloat === 0) return numFloat.toFixed(precision);
                if (Math.abs(numFloat) < 1e-9) return numFloat.toExponential(precision); 
                
                if (Math.abs(numFloat) >= 1e15) return numFloat.toExponential(2); // Quadrillion+
                if (Math.abs(numFloat) >= 1e12) return (numFloat / 1e12).toFixed(Math.max(precision, 2)) + "T"; // Trillion
                if (Math.abs(numFloat) >= 1e9) return (numFloat / 1e9).toFixed(Math.max(precision, 2)) + "B"; // Billion
                if (Math.abs(numFloat) >= 1e6) return (numFloat / 1e6).toFixed(Math.max(precision, 2)) + "M"; // Million
                if (Math.abs(numFloat) >= 1e3) return (numFloat / 1e3).toFixed(Math.max(precision,1)) + "k"; // Thousand
                
                return numFloat.toLocaleString(undefined, { 
                    minimumFractionDigits: precision, 
                    maximumFractionDigits: precision 
                });
            },

            showToast(message, isError = false, duration = 3000) {
                const toast = document.getElementById('toast-notification');
                const toastMessage = document.getElementById('toast-message');
                if(!toast || !toastMessage) { console.warn("Toast elements not found"); return; }
                
                if (toast.dataset.timeoutId) {
                    clearTimeout(parseInt(toast.dataset.timeoutId));
                }

                toastMessage.innerHTML = message; 
                toast.classList.remove('hidden', 'bg-red-500', 'bg-green-500', 'bg-blue-500', 'bg-purple-500');
                
                let bgColor = 'bg-green-500'; 
                if (isError) {
                    bgColor = 'bg-red-500';
                } else if (message.toLowerCase().includes('welcome back') || message.toLowerCase().includes('research complete')) { 
                    bgColor = 'bg-blue-500';
                } else if (message.toLowerCase().includes('prestiged!')) {
                    bgColor = 'bg-purple-500';
                }
                toast.classList.add(bgColor);
                
                const timeoutId = setTimeout(() => { 
                    toast.classList.add('hidden'); 
                    toast.removeAttribute('data-timeout-id');
                }, duration);
                toast.dataset.timeoutId = timeoutId.toString();
            },

            showModal(title, message, onConfirm) { 
                const modal = document.getElementById('confirmation-modal');
                const modalTitle = document.getElementById('modal-title');
                const modalMessage = document.getElementById('modal-message');
                const confirmButton = document.getElementById('modal-confirm');
                const cancelButton = document.getElementById('modal-cancel');
                if (!modal || !modalTitle || !modalMessage || !confirmButton || !cancelButton) { console.warn("Modal elements not found"); return; }
                
                modalTitle.textContent = title;
                modalMessage.innerHTML = message; // Use innerHTML for potential formatting in message
                
                const newConfirmButton = confirmButton.cloneNode(true);
                confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
                
                const newCancelButton = cancelButton.cloneNode(true);
                cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

                newConfirmButton.onclick = async () => { 
                    if (typeof onConfirm === 'function') { 
                        try { 
                            await onConfirm(); 
                        } catch (e) { 
                            console.error("Error in modal confirm callback:", e); 
                            this.showToast("An error occurred.", true);
                        } 
                    }
                    modal.classList.add('hidden');
                };
                newCancelButton.onclick = () => { 
                    modal.classList.add('hidden'); 
                };
                
                modal.classList.remove('hidden');
            }
        };

        document.addEventListener('DOMContentLoaded', () => { 
            Game.init().catch(err => {
                console.error("Error during Game.init():", err);
                const loadingMessage = document.getElementById('loading-message');
                if (loadingMessage) {
                    loadingMessage.innerHTML = '<p class="text-xl sm:text-2xl text-red-500">Failed to load game. Please try refreshing.</p>';
                    loadingMessage.classList.remove('hidden');
                }
            });
        });
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .tab-button { transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, color 0.2s ease-in-out; }
        .tab-button:hover { transform: translateY(-1px); }
        .tab-button.bg-sky-600 { 
            box-shadow: inset 0 -2px 0 0 #0284c7; /* Tailwind sky-600 */
        }
        .grid { align-items: stretch; } 
        .grid > div { display: flex; flex-direction: column; } 
        .grid > div > div:first-child { flex-grow: 1; } 
        #achievements-container, #processors-container, #market-container, #research-container, #prestige-upgrades-container { max-height: 70vh; overflow-y: auto; } 
        /* Scrollbar styling for webkit browsers */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; /* slate-800 */ border-radius: 10px;}
        ::-webkit-scrollbar-thumb { background: #38bdf8; /* sky-400 */ border-radius: 10px;}
        ::-webkit-scrollbar-thumb:hover { background: #0ea5e9; /* sky-500 */ }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col items-center p-2 sm:p-4 selection:bg-sky-500 selection:text-white">

    <div id="loading-message" class="fixed inset-0 bg-slate-900 bg-opacity-95 flex items-center justify-center z-[200]">
        <p class="text-xl sm:text-2xl text-sky-400 animate-pulse">Loading Mine Tycoon...</p>
    </div>

    <header class="w-full max-w-7xl mb-4 sm:mb-6 text-center pt-2 sm:pt-4">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-sky-400">Mine Tycoon</h1>
        <p id="money-display" class="text-2xl sm:text-3xl md:text-4xl font-semibold text-green-400 mt-1 sm:mt-2 mb-2 sm:mb-3">$0.00</p>
        <button data-action="sellAllResources" class="bg-yellow-500 hover:bg-yellow-600 text-slate-900 font-bold py-2 px-4 sm:py-2.5 sm:px-8 rounded-lg shadow-md transition-all duration-150 ease-in-out transform hover:scale-105 text-sm sm:text-base">
            Sell All (Quick Sell)
        </button>
    </header>

    <nav class="w-full max-w-7xl mb-6 sm:mb-8 sticky top-0 z-40 bg-slate-900 py-2 shadow-sm">
        <div class="flex flex-col items-center bg-slate-800 p-1 sm:p-1.5 rounded-lg shadow-lg">
            <div class="flex justify-center space-x-1 sm:space-x-2 w-full mb-1 sm:mb-1.5">
                <button data-tab="mines" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Mines</button>
                <button data-tab="upgrades" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Upgrades</button>
                <button data-tab="investments" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Invest</button>
            </div>
            <div class="flex justify-center space-x-1 sm:space-x-2 w-full mb-1 sm:mb-1.5">
                <button data-tab="process" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Process</button>
                <button data-tab="market" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Market</button>
                <button data-tab="achievements" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Achieve</button>
            </div>
            <div class="flex justify-center space-x-1 sm:space-x-2 w-full">
                 <button data-tab="research" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Research</button>
                 <button data-tab="prestige" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Prestige</button>
                <button data-tab="settings" class="tab-button flex-1 py-1.5 px-2 sm:py-2 sm:px-4 rounded-md bg-sky-800 text-sky-200 hover:text-white font-medium text-xs sm:text-sm">Settings</button>
            </div>
        </div>
    </nav>

    <main class="w-full max-w-7xl px-1 sm:px-2">
        <div id="mines-tab-content">
            <div id="resources-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 sm:gap-4">
            </div>
        </div>

        <div id="upgrades-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Global Upgrades</h2>
            <div id="global-upgrades-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 sm:gap-5">
            </div>
        </div>

        <div id="investments-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Investment Market</h2>
            <div id="portfolio-summary" class="bg-slate-800 p-3 sm:p-4 rounded-lg shadow-md mb-4 sm:mb-6 text-center text-xs sm:text-sm">
            </div>
            <div id="investments-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-5">
            </div>
        </div>

        <div id="achievements-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 sm:mb-8 text-sky-300 text-center">Achievements</h2>
            <div id="achievements-container"> 
            </div>
        </div>

        <div id="process-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Resource Processors</h2>
            <div id="processors-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-5">
            </div>
        </div>

        <div id="market-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Sell Resources</h2>
            <div id="market-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 sm:gap-4">
            </div>
        </div>

        <div id="research-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Research & Development</h2>
            <div id="research-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-5">
            </div>
        </div>

        <div id="prestige-tab-content" class="hidden">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-purple-400 text-center">Prestige System</h2>
            </div>
        
        <div id="settings-tab-content" class="hidden"> 
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 sm:mb-6 text-sky-300 text-center">Game Settings</h2>
            <div class="max-w-md mx-auto bg-slate-800 p-4 sm:p-6 rounded-lg shadow-xl">
                <div class="mb-6">
                    <h3 class="text-lg sm:text-xl font-medium text-yellow-400 mb-2">Download Save File</h3>
                    <p class="text-xs sm:text-sm text-slate-400 mb-3">Download your current game progress as a JSON file. This can be used for backups or transferring saves.</p>
                    <button data-action="downloadSave" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-150 ease-in-out transform hover:scale-105 text-sm sm:text-base">
                        Download Save
                    </button>
                </div>
                <div class="mb-6 pt-6 border-t border-slate-700">
                    <h3 class="text-lg sm:text-xl font-medium text-yellow-400 mb-2">Load Save File</h3>
                    <p class="text-xs sm:text-sm text-slate-400 mb-3">Load your game progress from a previously downloaded JSON file. This will overwrite your current game state in this browser session and attempt to sync with the cloud if logged in.</p>
                    <input type="file" id="load-save-input" accept=".json" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-sky-500 file:text-white hover:file:bg-sky-600 cursor-pointer"/>
                </div>
                <div class="mb-6 pt-6 border-t border-slate-700">
                    <h3 class="text-lg sm:text-xl font-medium text-yellow-400 mb-2">Reset Game</h3>
                    <p class="text-xs sm:text-sm text-slate-400 mb-3">Warning: This will erase all your current progress, including money, resources, upgrades, achievements, and Prestige. This action cannot be undone.</p>
                    <button data-action="resetGame" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-150 ease-in-out transform hover:scale-105 text-sm sm:text-base">
                        Reset All Progress
                    </button>
                </div>
                 <div class="mt-6 pt-4 border-t border-slate-700">
                    <p class="text-xs text-slate-500 text-center">Player ID: <span id="user-id-display-settings" class="font-mono">Loading...</span></p>
                </div>
            </div>
        </div>

    </main>

    <div id="toast-notification" class="fixed bottom-3 right-3 sm:bottom-5 sm:right-5 p-3 sm:p-4 rounded-lg text-white shadow-xl hidden transition-all duration-300 ease-in-out z-[150] text-xs sm:text-sm max-w-xs sm:max-w-sm break-words">
        <p id="toast-message"></p>
    </div>

    <div id="confirmation-modal" class="fixed inset-0 bg-slate-900 bg-opacity-80 flex items-center justify-center p-4 hidden z-[200]">
        <div class="bg-slate-800 p-4 sm:p-6 rounded-lg shadow-2xl max-w-xs sm:max-w-sm w-full border border-slate-700">
            <h3 id="modal-title" class="text-lg sm:text-xl font-semibold text-sky-400 mb-3 sm:mb-4">Confirm Action</h3>
            <p id="modal-message" class="text-sm sm:text-base text-slate-300 mb-4 sm:mb-6">Are you sure?</p>
            <div class="flex justify-end space-x-2 sm:space-x-3">
                <button id="modal-cancel" class="bg-slate-600 hover:bg-slate-500 text-slate-100 font-medium py-1.5 px-3 sm:py-2 sm:px-4 rounded-md transform hover:scale-105 transition-transform text-sm sm:text-base">Cancel</button>
                <button id="modal-confirm" class="bg-red-500 hover:bg-red-600 text-white font-medium py-1.5 px-3 sm:py-2 sm:px-4 rounded-md transform hover:scale-105 transition-transform text-sm sm:text-base">Confirm</button>
            </div>
        </div>
    </div>

    <footer class="w-full max-w-7xl mt-8 sm:mt-12 py-4 sm:py-6 text-center text-xs sm:text-sm text-slate-500 border-t border-slate-700">
        Mine Tycoon &copy; 2024-2025. Prestige & Bulk Buy Update.
    </footer>

</body>
</html>
